<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->lexunrank</Title>
   <Purpose><!--This is the second line of the .m file-->lexunrank gives the the $k$-combination of $n$ elements of position $N$ in the lexicographic order of all combinations</Purpose>
   <Description><!--Description section--></Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>n</Name>
         <ShortDesc>Number of elements</ShortDesc>
         <TypeInd>A non negative integer &amp;gt; k</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single|double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>k</Name>
         <ShortDesc>Items to choose from the set of n elements</ShortDesc>
         <TypeInd>A non negative integer</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single|double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>N</Name>
         <ShortDesc>Position N in the reverse co-lexicographic order of such&#xD;
        combinations</ShortDesc>
         <TypeInd>A non negative integer between 0 and bc(n,p)-1</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single|double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>pascalM</Name>
         <ShortDesc>Pascal matrix</ShortDesc>
         <TypeInd>Matrix</TypeInd>
         <LongDesc>The Pascal matrix as given by the MATLAB function pascal(n).&#xD;
           In applications where lexunrank is called many times, it is preferable&#xD;
           to compute the Pascal matrix once outside lexunrank, and pass it&#xD;
           to lexunrank as optional argument. Otherwise, the required binomial&#xD;
           coeffients are computed inside lexunrank using function bc and, when&#xD;
           possible, using the traditional recurrent formula.&#xD;
           </LongDesc>
         <Example>&lt;code&gt;pascal(n)&#xD;
&lt;/code&gt;</Example>
         <DataType>single|double</DataType>
         <ReqArg>0</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION--></OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>kcomb</Name>
         <ShortDesc> Vector of length k</ShortDesc>
         <TypeInd>The $k$-combination of n elements at position&#xD;
           N.</TypeInd>
         <LongDesc> The position is relative to a reverse co-lexicographic order&#xD;
           of the combinations or, equivalently, of position bc(n,k)-N in&#xD;
           the lexicographic order of the same combinations.&#xD;
           Data Types - single|double</LongDesc>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>calls</Name>
         <ShortDesc> Scalar</ShortDesc>
         <TypeInd>Binomial coefficients.</TypeInd>
         <LongDesc> The number of binomial coefficients used to compute the&#xD;
           $k$-combination. &#xD;
           Data Types - single|double</LongDesc>
         <Struct> </Struct>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->
   REMARKS ON THE INPUT ARGUMENTS.&#xD;
&#xD;
   Input checks are intentionally avoided, as lexunrank is supposed to be&#xD;
   called many times, for sampling subsets. Thus, please ensure that:&#xD;
   - k &amp;lt; n;&#xD;
   - N is an integer between 0 and bc(n,p)-1.&#xD;
   It is possible to enable checks, by changing an internal "if" statement to 1.&#xD;
&#xD;
   REMARKS ON THE OUTPUT ARGUMENTS.&#xD;
&#xD;
   As $n$ increases, 'calls' becomes much smaller than 'ncomb'. This means&#xD;
   that lexunrank(n,k,N) is extremely convenient if you are interested in&#xD;
   one or several, but not all, $k$-combinations at given generation&#xD;
   order(s) N.&#xD;
&#xD;
   To generate all combinations in lexicographic order, it is more &#xD;
   convenient using the FSDA function combsFS. The MATLAB function&#xD;
   with the same purpose, nchoosek(1:4,3), is much less efficient.&#xD;
&#xD;
   ON THE LEXICOGRAPHIC ORDERING.&#xD;
&#xD;
   lexunrank(n,k,N) gives the $k$-combination of n elements of position N&#xD;
   in the reverse co-lexicographic order of such combinations or,&#xD;
   equivalently, of position bc(n,k)-N in the lexicographic order of the&#xD;
   same combinations.&#xD;
   &#xD;
   Note that, in this implementation of the lexicographic unrank, N ranges&#xD;
   over the integers between 0 and bc(n,k)-1. For details see the&#xD;
   "combinatorial number system" discussed by Knuth (2005), pp. 5-6.&#xD;
&#xD;
   To clarify with an example the meaning of the different orders, while&#xD;
   the lexicographic order of the 2-combinations of 3 elements are:&#xD;
   &#xD;
   \[ &#xD;
     \left( &#xD;
        \begin{array}{ccc}&#xD;
           1  &amp;   2  &amp;   3     \\&#xD;
           1  &amp;   2  &amp;   4     \\&#xD;
           1  &amp;   3  &amp;   4     \\&#xD;
           2  &amp;   3  &amp;   4 &#xD;
        \end{array} &#xD;
      \right)&#xD;
   \] &#xD;
&#xD;
   the co-lexicographic order of the same combinations are&#xD;
   &#xD;
   \[ &#xD;
     \left( &#xD;
        \begin{array}{ccc}&#xD;
           3   &amp;  2  &amp;   1     \\&#xD;
           4   &amp;  2  &amp;   1     \\&#xD;
           4   &amp;  3  &amp;   1     \\&#xD;
           4   &amp;  3  &amp;   2&#xD;
        \end{array} &#xD;
      \right)&#xD;
   \] &#xD;
   &#xD;
   and the reverse co-lexicographic order of the original combinations are:&#xD;
&#xD;
   \[ &#xD;
     \left( &#xD;
        \begin{array}{ccc}&#xD;
           4   &amp;  3  &amp;   2     \\&#xD;
           4   &amp;  3  &amp;   1     \\&#xD;
           4   &amp;  2  &amp;   1     \\&#xD;
           3   &amp;  2  &amp;   1     &#xD;
        \end{array} &#xD;
      \right)&#xD;
   \] &#xD;
&#xD;
   The reasons for choosing a co-lexicographic unrank is that right-to-left &#xD;
   array filling is much faster and elegant. The reverse is due to a similar &#xD;
   motivation.&#xD;
&#xD;
&#xD;
   ALGORITMIC DETAILS.&#xD;
&#xD;
 Given the totally ordered set $S=\{1,2,\ldots,n\}$, a $k$-combination is&#xD;
 a subset $\{x_1, \ldots, x_k\}$ of $S$. Consider the $n$-lists of&#xD;
 elements of the set $\{0,1\}$, i.e. the vertices of the hypercube $V_n$.&#xD;
 Each $k$-combination $\{x_1,\ldots,x_k\}$ can be associated to the&#xD;
 $n$-list having a 1 at position $x_1$, \ldots, $x_k$, and a 0 elsewhere.&#xD;
&#xD;
 Example:&#xD;
   2-combinations of $\{1,2,3,4\}$: $\{1,2\}$, $\{1,3\}$, $\{1,4\}$,&#xD;
   $\{2,3\}$, $\{2,4\}$, $\{3,4\}$. Corresponding 4-lists of $\{0,1\}$:&#xD;
   $1100$,  $1010$,  $1001$,  $0110$, $0101$,  $0011$.&#xD;
&#xD;
 The $n$-lists of $\{0,1\}$ containing $k$ times 1, and therefore&#xD;
 equivalently the $k$-combinations of $n$-elements of $S$, can be&#xD;
 generated in lexicographic order with an algorithm that builds the&#xD;
 $k$-list of position $t+1$ using only the $k$-list of position $t$, and&#xD;
 which stops without counting the combinations generated. For example, the&#xD;
 MATLAB function NCHOOSEK(S,k), where $S$ is the row vector of length $n$&#xD;
 of the elements of $S$, creates in lexicographic order a $k$ columns&#xD;
 matrix whose rows consist of all possible combinations of the $n$&#xD;
 elements of $S$ taken $k$ at a time. The number of such combinations,&#xD;
 given by the binomial coefficient $n!/((n-k)! k!)$, can be also computed&#xD;
 with the function NCHOOSEK by replacing the first argument, the row&#xD;
 vector $S$, with the scalar $n$.&#xD;
&#xD;
 Unfortunately the binomial coefficient increases rapidly with $n$, which&#xD;
 makes the generation of all $k$-combinations computationally hard: with&#xD;
 NCHOOSEK the task is impractical even for values just above 15. However,&#xD;
 a lexicographic algorithm implements a one-to-one correspondence between&#xD;
 the $k$-combinations and the generation order, i.e. the set of numbers $s&#xD;
 = 1,\ldots,(n!/((n-k)!k!))$. This fact is used in our function to&#xD;
 determine the $n$-list corresponding to the $k$-combination $\{x_1,&#xD;
 \ldots, x_k\}$ which would be generated by the lexicographic algorithm at&#xD;
 a given desired position $N$. This is useful in a number of applications&#xD;
 which require one or several, but not all, $k$-combinations at given&#xD;
 generation order(s).&#xD;
&#xD;
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Lehmer, D. H. (1964). The machine tools of combinatorics. In E. F.&#xD;
   Beckenbach (Ed.), Applied Combinatorial Mathematics, pp. 5--31. New York, Wiley.</Item>
      <Item>Knuth, D. (2005). Generating All Combinations and Partitions. The Art of&#xD;
   Computer Programming, Vol. 4, Fascicle 3. Reading, Mass., Addison-Wesley.</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>combsFS</Item>
      <Item>nchoosek</Item>
      <Item>bc</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>7th 2 combination chosen among 5 element.</Title>
         <Desc/>
         <MATLABcode>
        n = 5; &#xD;
        k = 2; &#xD;
        N = 7;&#xD;
        kcomb=lexunrank(n,k,N)&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>number of binomial coefficient calls necessary to compute the 7th 2 combination chosen among 5 element.</Title>
         <Desc/>
         <MATLABcode>
        [~,calls]=lexunrank(n,k,N)&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>7th 2 combination chosen among 5 element, using the pascal matrix.</Title>
         <Desc/>
         <MATLABcode>
        [kcomb,calls]=lexunrank(n,k,N,pascal(n))&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>Additional example on the use of lexunrank.</Title>
         <Desc>&#xD;
     Standard use.&#xD;</Desc>
         <MATLABcode>
    n = 4; p = 3;&#xD;
    % number of p-combinations out of n&#xD;
    n_bc = bc(n,p);&#xD;
    % Pascal matrix&#xD;
    pascalM=pascal(n);&#xD;
    % n_bc is the Pascal cell in position (n-p+1,p+1)&#xD;
    n_bc==pascalM(n-p+1,p+1)&#xD;
    % all p-combinations in reverse-colex order generated by lexunrank&#xD;
    % using a loop with rank integers ranging from 0 to bc(n,p)-1&#xD;
    all_recolex = nan(n_bc,p);&#xD;
    for N_lex = 0:n_bc-1&#xD;
        all_recolex(N_lex+1,:) = lexunrank(n,p,N_lex);&#xD;
    end&#xD;
    all_recolex&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Additional example on the use of lexunrank.</Title>
         <Desc>&#xD;
     To change from reverse-colex to colex.&#xD;</Desc>
         <MATLABcode>
    all_colex = flipud(all_recolex)&#xD;
    % and to change from colex to lex, it is sufficient this&#xD;
    all_lex = fliplr(all_colex)&#xD;
&#xD;
    % all p-combinations in lexi order generated using combsFS&#xD;
    all_lex_combs = combsFS(1:n,p)&#xD;
&#xD;
    % the combination at Lexi position N_lex=3 is generated by lexiunrank&#xD;
    % in Colex position&#xD;
    N_lex = 3; N_colex = n_bc - N_lex ;&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Additional example on the use of lexunrank.</Title>
         <Desc>&#xD;
     Use of lexunrank with pascal matrix&#xD;</Desc>
         <MATLABcode>
    kcomb = lexunrank(n,p,N_colex,pascal(n))&#xD;
    % This is without Pascal matrix&#xD;
    kcomb2 = lexunrank(n,p,N_colex)&#xD;
    % Just as confirmation, the combination in the lexi order is&#xD;
    all_lex_combs(N_lex,:)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>