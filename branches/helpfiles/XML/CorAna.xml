<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->CorAna</Title>
   <Purpose><!--This is the second line of the .m file-->CorAna performs correspondence analysis
</Purpose>
   <Description><!--Description section--></Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>N</Name>
         <ShortDesc>Contingency table (default) or n-by-2 input dataset.</ShortDesc>
         <TypeInd>Matrix or Table.</TypeInd>
         <LongDesc>Matrix or table which contains the input contingency table (say of size I-by-J) or the original data matrix.
In this last case N=crosstab(N(:,1),N(:,2)). As default procedure assumes that the input is a contingency table.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>k</Name>
         <ShortDesc>Number of dimensions to retain.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which contains the number of dimensions to retain.
The default value of k is 2.</LongDesc>
         <Example>'k',3</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Lr</Name>
         <ShortDesc>Vector of row labels.</ShortDesc>
         <TypeInd>Cell.</TypeInd>
         <LongDesc>Cell containing the labels of the rows of the input contingency matrix N. This option is unnecessary if N is a table, because in this case Lr=N.Properties.RowNames;</LongDesc>
         <Example>'Lr',{'a' 'b' 'c'}</Example>
         <DataType>cell array of strings</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Lc</Name>
         <ShortDesc>Vector of column labels.</ShortDesc>
         <TypeInd>Cell.</TypeInd>
         <LongDesc>Cell containing the labels of the columns of the input contingency matrix N. This option is unnecessary if N is a table, because in this case Lc=N.Properties.VariableNames;</LongDesc>
         <Example>'Lc',{'c1' c2' 'c3' 'c4'}</Example>
         <DataType>cell array of strings</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Sup</Name>
         <ShortDesc>Structure containing indexes or names of supplementary rows or columns.</ShortDesc>
         <TypeInd>Structure.</TypeInd>
         <LongDesc>Structure with the following fields.
Sup.r = vector containing row indexes or vector of cell array of strings or table or 2D numeric array, containing supplementary rows.
If indexes or cell array of strings are supplied in a vector, we assume that supplementary rows belong to contingency table N. For example:
- if Sup.r=[2 5] (that is Sup.r is a numeric vector which contains row indexes) we use rows 2 and 5 of the input contingency table as supplementary rows.
- if Sup.r={'Junior-Managers' 'Senior-Employees'} (that is Sup.r is a cell array of strings) we use rows named 'Junior-Managers' and 'Senior-Employees' of the input contingency table as supplementary rows. Of course the length of Sup.r must be smaller than the number of rows of the contigencey matrix divided by 2.
- if Sup.r is a table, or a 2D array supplementary rows do not belong to N. Note that if Sup.r is a table, the labels of the rows are taken directly from the table. If on the other hand Sup.r is a matrix the names of the rows of the supplementary units can be given using Sup.Lr as a cell array of strings.
Sup.Lr = cell array of strings containing the labels of the supplementary units if Sup.r is a 2D numeric array.
Sup.c = vector containing column indexes or vector of cell array of strings or table or 2D numeric array use as supplementary columns, or table or 2D numeric array containing supplementary rows.
If indexes or cell array of strings are supplied in a vector, we assume that supplementary columns belong to contingency table N. For example:
- if Sup.c=[2 3] (that is Sup.c is a numeric vector which contains column indexes) we use columns 2 and 3 of the input contingency table as supplementary columns.
- if Sup.c={'Smokers' 'NonSmokers'} (that is Sup.c is a cell array of strings) we use columns of the contingency table labelled 'Smokers' and 'NonSmokers' of the input contingency table N as supplementary columns.
Of course the length of Sup.c must be smaller than the number of columns of the contigencey matrix divided by 2.
- If Sup.c is a table, or a 2D array supplementary columns do not belong to N. Note that if Sup.c is a table, the labels of the columns are taken directly from the table. If on the other hand Sup.c is a matrix the names of the columns of the supplementary units can be given using Sup.Lc as a cell array of strings.
Sup.Lc = cell array of strings containing the labels of the supplementary units if Sup.r is a 2D numeric array.
REMARK: The default value of Sup is a missing value that is we assume that there are no supplementary rows or columns.</LongDesc>
         <Example>'Sup',Sup=struct; Sup.c={'c2' 'c4'}</Example>
         <DataType>struct</DataType>
         <Struct>
            <ItemCell>
               <Value>r</Value>
               <Description>vector containing row indexes or vector of cell&#xD;
                       array of strings or table or 2D numeric array,&#xD;
                       containing supplementary rows.&#xD;
                       If indexes or cell array of strings are supplied in&#xD;
                       a vector, we assume that supplementary rows belong&#xD;
                       to contingency table N. For example:&#xD;
                       - if Sup.r=[2 5] (that is Sup.r is a numeric vector&#xD;
                         which contains row indexes) we use rows 2 and 5&#xD;
                         of the input contingency table as supplementary&#xD;
                         rows.&#xD;
                       - if Sup.r={'Junior-Managers' 'Senior-Employees'}&#xD;
                         (that is Sup.r is a cell array of strings) we use&#xD;
                         rows named 'Junior-Managers' and&#xD;
                         'Senior-Employees' of the input contingency table&#xD;
                         as supplementary rows. Of course the length of&#xD;
                         Sup.r must be smaller than the number of rows of&#xD;
                         the contigencey matrix divided by 2.&#xD;
                      - if Sup.r is a table, or a 2D array&#xD;
                         supplementary rows do not belong to N. Note that&#xD;
                         if Sup.r is a table, the labels of the rows are&#xD;
                         taken directly from the table. If on the other&#xD;
                         hand Sup.r is a matrix the names of the rows&#xD;
                         of the supplementary units can be given using&#xD;
                         Sup.Lr as a cell array of strings.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Lr</Value>
               <Description>cell array of strings containing the labels of the&#xD;
                       supplementary units if Sup.r is a 2D numeric array.</Description>
            </ItemCell>
            <ItemCell>
               <Value>c</Value>
               <Description>vector containing column indexes or vector of cell&#xD;
                       array of strings or table or 2D numeric array&#xD;
                       use as supplementary columns, or table or 2D&#xD;
                       numeric array containing supplementary rows.&#xD;
                       If indexes or cell array of strings are supplied in&#xD;
                       a vector, we assume that supplementary columns belong&#xD;
                       to contingency table N. For example:&#xD;
                       - if Sup.c=[2 3] (that is Sup.c is a&#xD;
                       numeric vector which contains column indexes) we use&#xD;
                       columns 2 and 3 of the input contingency table as&#xD;
                       supplementary columns.&#xD;
                       - if Sup.c={'Smokers' 'NonSmokers'}&#xD;
                        (that is Sup.c is a cell array of strings) we use&#xD;
                        columns of the contingency table labelled&#xD;
                        'Smokers' and 'NonSmokers' of the input&#xD;
                        contingency table N as supplementary columns.&#xD;
                        Of course the length of Sup.c must be smaller than&#xD;
                        the number of columns of the contigencey matrix&#xD;
                        divided by 2.&#xD;
                       - If Sup.c is a table, or a 2D array&#xD;
                         supplementary columns do not belong to N. Note that&#xD;
                         if Sup.c is a table, the labels of the columns are&#xD;
                         taken directly from the table. If on the other&#xD;
                         hand Sup.c is a matrix the names of the columns&#xD;
                         of the supplementary units can be given using&#xD;
                         Sup.Lc as a cell array of strings.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Lc</Value>
               <Description>cell array of strings containing the labels of the&#xD;
                       supplementary units if Sup.r is a 2D numeric array.&#xD;
                                              REMARK: The default value of Sup is a missing value&#xD;
                       that is we assume that there are no supplementary&#xD;
                       rows or columns.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>datamatrix</Name>
         <ShortDesc>Data matrix or contingency table.</ShortDesc>
         <TypeInd>Boolean.</TypeInd>
         <LongDesc>If datamatrix is true the first input argument N is forced to be interpreted as a data matrix, else if the input argument is false N is treated as a contingency table. The default value of datamatrix is false, that is the procedure automatically considers N as a contingency table</LongDesc>
         <Example>'datamatrix',true</Example>
         <DataType>logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen.</ShortDesc>
         <TypeInd>Scalar or structure.</TypeInd>
         <LongDesc>If plots = 1, a plot which shows the Principal coordinates of rows and columns is shown on the screen. If plots is a structure it may contain the following fields:
plots.alpha = type of plot, scalar in the interval [0 1] or a string identifying the type of coordinates to use in the plot.
If $plots.alpha='rowprincipal'$ the row points are in principal coordinates and the column coordinates are standard coordinates. Distances between row points are (approximated) chi-squared distances (row-metric-preserving). The position of the row points are at the weighted average of the column points.
Note that 'rowprincipal' can also be specified setting plots.alpha=1.
If $plots.alpha='colprincipal'$, the column coordinates are referred to as principal coordinates and the row coordinates as standard coordinates.
Distances between column points are (approximated) chi-squared distances (column-metric-preserving). The position of the column points are at the weighted average of the row points.
Note that 'colwprincipal' can also be specified setting plots.alpha=0.
If $plots.alpha='symbiplot'$, the row and column coordinates are scaled similarly. The sum of weighted squared coordinates for each dimension is equal to the corresponding singular values. These coordinates are often called symmetrical coordinates. This representation is particularly useful if one is primarily interested in the relationships between categories of row and column variables rather than in the distances among rows or among columns. 'symbiplot' can also be specified setting plots.alpha=0.5;
If $plots.alpha='bothprincipal'$, both the rows and columns are depicted in principal coordinates. Such a plot is often referred to as a symmetrical plot or French symemtrical model. Note that such a symmetrical plot does not provide a feasible solution in the sense that it does not approximate matrix $D_r^{-0.5}(P-rc')D_c^{-0.5}$.
plots.FontSize = scalar which specifies the font size of row (column) labels. The default value is 10.
plots.MarkerSize = scalar which specifies the marker size of symbols associated with rows or columns. The default value is 10.</LongDesc>
         <Example>'plots',1</Example>
         <DataType>scalar double | struct</DataType>
         <Struct>
            <ItemCell>
               <Value>alpha</Value>
               <Description>type of plot, scalar in the interval [0 1] or&#xD;
               a string identifying the type of coordinates to use in the&#xD;
               plot.&#xD;
               If $plots.alpha='rowprincipal'$ the row points are in&#xD;
                   principal coordinates and the column coordinates are&#xD;
                   standard coordinates. Distances between row points are&#xD;
                   (approximated) chi-squared distances&#xD;
                   (row-metric-preserving). The position of the row points&#xD;
                   are at the weighted average of the column points.&#xD;
                   Note that 'rowprincipal' can also be specified setting&#xD;
                   plots.alpha=1.&#xD;
               If $plots.alpha='colprincipal'$, the column&#xD;
                   coordinates are referred to as principal coordinates&#xD;
                   and the row coordinates as standard coordinates.&#xD;
                   Distances between column points are (approximated)&#xD;
                   chi-squared distances (column-metric-preserving). The&#xD;
                   position of the column points are at the weighted&#xD;
                   average of the row points.&#xD;
                   Note that 'colwprincipal' can also be&#xD;
                   specified setting plots.alpha=0.&#xD;
               If $plots.alpha='symbiplot'$, the row and column coordinates&#xD;
                   are scaled similarly. The sum of weighted squared&#xD;
                   coordinates for each dimension is equal to the&#xD;
                   corresponding singular values. These coordinates are often&#xD;
                   called symmetrical coordinates. This representation is&#xD;
                   particularly useful if one is primarily interested in&#xD;
                   the relationships between categories of row and column&#xD;
                   variables rather than in the distances among rows or&#xD;
                   among columns. 'symbiplot' can also be specified&#xD;
                   setting plots.alpha=0.5;&#xD;
               If $plots.alpha='bothprincipal'$, both the rows and columns&#xD;
                   are depicted in principal coordinates. Such a plot is&#xD;
                   often referred to as a symmetrical plot or French&#xD;
                   symemtrical model. Note that such a symmetrical plot&#xD;
                   does not provide a feasible solution in the sense that&#xD;
                   it does not approximate matrix&#xD;
                   $D_r^{-0.5}(P-rc')D_c^{-0.5}$.</Description>
            </ItemCell>
            <ItemCell>
               <Value>FontSize</Value>
               <Description>scalar which specifies the font size of row&#xD;
                   (column) labels. The default value is 10.</Description>
            </ItemCell>
            <ItemCell>
               <Value>MarkerSize</Value>
               <Description>scalar which specifies the marker size&#xD;
                   of symbols associated with rows or columns. The default&#xD;
                   value is 10.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>dispresults</Name>
         <ShortDesc>Display results on the screen.</ShortDesc>
         <TypeInd>Boolean.</TypeInd>
         <LongDesc>If dispresults is true (default) it is possible to see on the screen all the summary results of the analysis.</LongDesc>
         <Example>'dispresults',false</Example>
         <DataType>Boolean</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>d1</Name>
         <ShortDesc>Dimension to show on the horizontal axis.</ShortDesc>
         <TypeInd>Positive integer.</TypeInd>
         <LongDesc>Positive integer in the range 1, 2, .., K which indicates the dimension to show on the x axis. The default value of d1 is 1.</LongDesc>
         <Example>'d1',2</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>d2</Name>
         <ShortDesc>Dimension to show on the vertical axis.</ShortDesc>
         <TypeInd>Positive integer.</TypeInd>
         <LongDesc>Positive integer in the range 1, 2, .., K which indicates the dimension to show on the y axis. The default value of d2 is 2.</LongDesc>
         <Example>'d2',3</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Structure>
            <ItemCell>
               <Value>Lr</Value>
               <Description>cell of length $I$ containing the labels of active rows (i.e. the rows which participated to the fit).</Description>
            </ItemCell>
            <ItemCell>
               <Value>Lc</Value>
               <Description>cell of length $J$ containing the labels of active columns (i.e. the columns which participated to the fit).</Description>
            </ItemCell>
            <ItemCell>
               <Value>N</Value>
               <Description>$I$-by-$J$-array containing contingency table referred to active rows and active columns (i.e.
referred to the rows/columns which participated to the fit). The $(i,j)$-th element is equal to $n_{ij}$, $i=1, 2, \ldots, I$ and $j=1, 2, \ldots, J$. The sum of the elements of out.P is $n$ (the grand total).</Description>
            </ItemCell>
            <ItemCell>
               <Value>Ntable</Value>
               <Description>Same as out.N but in table format (with row and column names).
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>I</Value>
               <Description>Number of active rows of contingency table.</Description>
            </ItemCell>
            <ItemCell>
               <Value>J</Value>
               <Description>Number of active columns of contingency table.</Description>
            </ItemCell>
            <ItemCell>
               <Value>n</Value>
               <Description>Grand total. out.n is equal to sum(sum(out.N)).
This is the number of observations.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Nhat</Value>
               <Description>$I$-by-$J$-array containing contingency table referred to active rows (i.e. referred to the rows which participated to the fit) under the independence hypothesis.
The $(i,j)$-th element is equal to $n_{i.}n_{.j}/n$, $i=1, 2, \ldots, I$ and $j=1, 2, \ldots, J$. The sum of the elements of out.Nhat is $n$ (the grand total).</Description>
            </ItemCell>
            <ItemCell>
               <Value>Nhattable</Value>
               <Description>Same as out.Nhat but in table format (with row and column names).</Description>
            </ItemCell>
            <ItemCell>
               <Value>P</Value>
               <Description>$I$-by-$J$-array containing correspondence matrix (proportions). The $(i,j)$-th element is equal to $n_{ij}/n$, $i=1, 2, \ldots, I$ and $j=1, 2, \ldots, J$. The sum of the elements of out.P is 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Ptable</Value>
               <Description>Same as out.P but in table format (with row and column names).
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>r</Value>
               <Description>Vector of length $I$ containing row masses.
\[
r=(f_{1.},	f_{2.}, \ldots, f_{I.})'
\]
$r$ is also the centroid of column profiles.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Dr</Value>
               <Description>Square matrix of size $I$ containing on the diagonal the row masses. This is matrix $D_r$.
\[
D_r=diag(r)
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>c</Value>
               <Description>Vector of length $J$ containing column masses.
\[
c=(f_{.1},	f_{.2}, \ldots, f_{.J})'
\]
$c$ is also the centroid of row profiles.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Dc</Value>
               <Description>Square matrix of size $J$ containing on the diagonal the column masses. This is matrix $D_c$.
\[
D_c=diag(c)
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>ProfilesRows</Value>
               <Description>$I$-by-$J$-matrix containing row profiles.
The $i,j$-th element of this matrix is given by $f_{ij}/f_{i.}=n_{ij}/n_{i.}$.
Written in matrix form:
\[
ProfilesRows = D_r^{-1} \times P
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>ProfilesCols</Value>
               <Description>$I$-by-$J$-matrix containing column profiles.
The $i,j$-th element of this matrix is given by $f_{ij}/f_{.j}=n_{ij}/n_{.j}$.
Written in matrix form:
\[
ProfilesCols = P \times D_c^{-1}
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>K</Value>
               <Description>Scalar integer containing the maximum number of dimensions. $K = \min(I-1,J-1)$.</Description>
            </ItemCell>
            <ItemCell>
               <Value>k</Value>
               <Description>Scalar integer containing the number of retained dimensions.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Residuals</Value>
               <Description>$I$-by-$J$-matrix containing standardized residuals.
\[
Residuals = D_r^{1/2} (D_r^{-1} P - r c') D_c^{-1/2} = D_r^{-1/2} (P - r c') D_c^{-1/2}
\]
With the singular value decomposition (SVD) we obtain that:
\[
Residuals = U \Gamma V'
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>TotalInertia</Value>
               <Description>Scalar containing total inertia. Total inertia is equal (for example) to the sum of the squares of the elements of matrix out.Residuals.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Chi2stat</Value>
               <Description>Scalar containing Chi-square statistic for the contingency table. $Chi2stat= TotalInertia \times n$.</Description>
            </ItemCell>
            <ItemCell>
               <Value>CramerV</Value>
               <Description>Scalar containing Cramer's $V$ index.
\[
V=\sqrt{Chi2stat/(n (\min(I,J)-1))}
\]
Cramer's index goes between 0 and 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>InertiaExplained</Value>
               <Description>matrix with 4 columnn.
- First column contains the singular values (the sum of the squared singular values is the total inertia).
- Second column contains the eigenvalues (the sum of the eigenvalues is the total inertia).
- Third column contains the variance explained by each latent dimension.
- Fourth column contains the cumulative variance explained by each dimension.</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsPri</Value>
               <Description>$I$-by-$K$ matrix containing principal coordinates of rows.
\[
RowsPri = D_r^{-1/2} \times U \times \Gamma;
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsPri</Value>
               <Description>$J$-by-$K$ matrix containing Principal coordinates of columns.
\[
ColsPri = D_c^{-1/2} \times V \times \Gamma;
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsSta</Value>
               <Description>$I$-by-$K$ matrix containing standard coordinates of rows.
\[
RowsSta = RowsPri \times \Gamma^{-1} = D_r^{-1/2} U \Gamma \Gamma^{-1}= D_r^{-1/2} U
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsSta</Value>
               <Description>$J$-by-$K$ matrix containing standard coordinates of columns.
\[
ColsSta = ColsPri \times \Gamma^{-1} = D_c^{-1/2} V \Gamma \Gamma^{-1}= D_c^{-1/2} V
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsSym</Value>
               <Description>$I$-by-$K$ matrix containing symmetrical coordinates of rows.
\[
RowsSym = D_r^{-1/2} \times U \times \Gamma^{1/2}
\]</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsSym</Value>
               <Description>$J$-by-$K$ matrix containing symmetrical coordinates of columns.
\[
ColsSym = D_c^{-1/2} \times V \times \Gamma^{1/2}
\]
Symmetric plot represents the row and column profiles simultaneously in a common space (Bendixen, 2003). In this case, only the distance between row points or the distance between column points can be really interpreted.
The distance between any row and column items is not meaningful! You can only make a general statements about the observed pattern. In order to interpret the distance between column and row points, the column profiles must be presented in row space or vice-versa. This type of map is called asymmetric biplot.</Description>
            </ItemCell>
            <ItemCell>
               <Value>InertiaRows</Value>
               <Description>$I$-by-$2$ matrix containing absolute and relative contribution of each row to total inertia.
The inertia of a point is the squared distance of point $d_i^2$ to the centroid. The absolute contribution of a point to total inertia is the inertia of the point multiplied by the point mass.
1st column = absolute contribution of each row to TotalInertia. The sum of values of the first column is equal to TotalInertia;
2nd column = relative contribution of each row to TotalInertia. The sum of the values of the second column is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>InertiaCols</Value>
               <Description>$J$-by-$2$ matrix containing absolute and relative contribution of each column to total inertia.
The inertia of a point is the squared distance of point $d_i^2$ to the centroid. The absolute contribution of a point to total inertia is the inertia of the point multiplied by the point mass.
1st column = absolute contribution of each column to TotalInertia. The sum of values of the first column is equal to TotalInertia;
2nd column = relative contribution of each column to TotalInertia. The sum of values of the second column is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Point2InertiaRows</Value>
               <Description>$I$-by-$K$ matrix containing relative contributions of rows to inertia of the dimension. The inertia of first latent dimension is given by $\lambda_1=\gamma_{11}^2$. The inertia of second latent dimension is given by $\lambda_2=\gamma_{22}^2$ .... The sum of each column of matrix Point2InertiaRows is equal to 1.
Remark: the points with the larger value of Point2Inertia are those which contribute the most to the definition of the dimension. If the row contributions were uniform, the expected value would be 1/size(contingeny_table,1) For a given dimension, any row with a contribution larger than this threshold could be considered as important in contributing to that dimension.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Point2InertiaCols</Value>
               <Description>$J$-by-$K$ matrix containing relative contributions of columns to inertia of the dimension. The sum of each column of matrix Point2InertiaCols is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Dim2InertiaRows</Value>
               <Description>$I$-by-$K$ matrix containing relative contributions of latent dimensions to inertia of the row points. These numbers can be interpreted as squared correlations and measures the degree of association between row points and a particular axis. The sum of each row of matrix Dim2InertiaRows is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Dim2InertiaCols</Value>
               <Description>$J$-by-$K$ matrix containing relative contributions of latent dimensions to inertia of the column points. These numbers can be interpreted as squared correlations and measure the degree of association between columns points and a particular axis. The sum of each row of matrix Dim2InertiaCols is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>cumsumDim2InertiaRows</Value>
               <Description>$I$-by-$K$ matrix containing cumulative sum of the contributions of latent dimensions to inertia of the row points. These cumulative sums are equivalent to the communalities in PCA.
The last column of matrix cumsumDim2InertiaRows is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>cumsumDim2InertiaCols</Value>
               <Description>$J$-by-$K$ matrix containing cumulative sum of the contributions of latent dimensions to inertia of the column points. These cumulative sums are equivalent to the communalities in PCA.
The last column of matrix cumsumDim2InertiaCols is equal to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>sqrtDim2InertiaRows</Value>
               <Description>$I$-by-$K$ matrix containing correlation of rows points with latent dimension axes. Similar to component loadings in PCA</Description>
            </ItemCell>
            <ItemCell>
               <Value>sqrtDim2InertiaCols</Value>
               <Description>$I$-by-$K$ matrix containing correlation of column points with latent dimension axes. Similar to component loadings in PCA.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Summary</Value>
               <Description>$K$-times-4 table containing summary results for correpondence analysis.
First column contains the singular values (the sum of the squared singular values is the total inertia).
Second column contains the eigenvalues (the sum of the eigenvalues is the total inertia).
Third column contains the variance explained by each latent dimension. Fourth column contains the cumulative variance explained by each dimension.
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>OverviewRows</Value>
               <Description>$I$-times-(k*3+2) table containing an overview of row points. More precisely, if we suppose that $k=2$, First column contains the row masses (vector $r$).
Second column contains the scores of first dimension.
Third column contains the scores of second dimension.
Fourth column contains the inertia of each point, where inertia of point is the squared distance of point $d_i^2$ to the centroid.
Fifth column contains the relative contribution of each point to the explanation of the inertia of the first dimension. The sum of the elements of this column is equal to 1.
Sixth column contains the relative contribution of each point to the explanation of the inertia of the second dimension. The sum of the elements of this column is equal to 1.
Seventh column contains the relative contribution of the first dimension to the explanation of the inertia of the point.
Eight column contains the relative contribution of the second dimension to the explanation of the inertia of the point.</Description>
            </ItemCell>
            <ItemCell>
               <Value>OverviewCols</Value>
               <Description>$J$-times-(k*3+2) table containing an overview of row points. More precisely if we suppose that $k=2$ First column contains the column masses (vector $c$).
Second column contains the scores of first dimension.
Third column contains the scores of second dimension.
Fourth column contains the inertia of each point, where inertia of point is the squared distance of point $d_i^2$ to the centroid.
Fifth column contains the relative contribution of each point to the explanation of the inertia of the first dimension. The sum of the elements of this column is equal to 1.
Sixth column contains the relative contribution of each point to the explanation of the inertia of the second dimension. The sum of the elements of this column is equal to 1.
Seventh column contains the relative contribution of the first dimension to the explanation of the inertia of the point.
Eight column contains the relative contribution of the second dimension to the explanation of the inertia of the point.
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>LrSup</Value>
               <Description>cell containing the labels of the supplementary rows (i.e. the rows whicg did not participate to the fit).</Description>
            </ItemCell>
            <ItemCell>
               <Value>LcSup</Value>
               <Description>cell containing the labels of supplementary columns (i.e. the columns which did not participate to the fit).</Description>
            </ItemCell>
            <ItemCell>
               <Value>SupRowsN</Value>
               <Description>matrix of size length(LrSup)-by-c referred to supplementary rows. If there are no supplementary rows this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>SupRowsNtable</Value>
               <Description>Same as out.SupRowsN but in table format (with row and column names). This is the contingency table referred to supplementary rows. If there are no supplementary rows this field is not present.
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>SupColsN</Value>
               <Description>matlab of size r-by-length(LcSup) referred to supplementary columns.
If there are no supplementary columns this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>SupColsNtable</Value>
               <Description>Same as out.SupColsN but in table format (with row and column names). This is the contingency table referred to supplementary columns.
If there are no supplementary columns this field is not present.
This output is present just if your MATLAB version is not&amp;lt;2013b.</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsPriSup</Value>
               <Description>Principal coordinates of supplementary rows.
If there are no supplementary rows this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsStaSup</Value>
               <Description>Standard coordinates of supplementary rows.
If there are no supplementary rows this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>RowsSymSup</Value>
               <Description>Symmetrical coordinates of supplementary rows.
If there are no supplementary rows this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsPriSup</Value>
               <Description>Principal coordinates of supplementary columns.
If there are no supplementary columns this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsStaSup</Value>
               <Description>Standard coordinates of of supplementary columns.
If there are no supplementary columns this field is not present.</Description>
            </ItemCell>
            <ItemCell>
               <Value>ColsSymSup</Value>
               <Description>Symmetrical coordinates of supplementary columns.
If there are no supplementary columns this field is not present.</Description>
            </ItemCell>
         </Structure>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION--></MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION-->&#xD;
&#xD;
 This function has been inspired by the code developed by:&#xD;
 Urbano Lorenzo-Seva (Rovira i Virgili University, Tarragona, Spain),&#xD;
 Michel van de Velden (Erasmus University, Rotterdam, The Netherlands),&#xD;
 and Henk A.L. Kiers (University of Groningen, Groningen, The Netherlands)&#xD;
 (See References).&#xD;
&#xD;
 
</Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Benzecri, J.-P. (1992), Correspondence Analysis Handbook, New-York, Dekker.</Item>
      <Item>Benzecri, J.-P. (1980), L'analyse des donnees tome 2: l'analyse des correspondances, Paris, Bordas.</Item>
      <Item>Greenacre, M.J. (1993), Correspondence Analysis in Practice, London, Academic Press.</Item>
      <Item>Gabriel, K.R. and Odoroff, C. (1990), Biplots in biomedical research, Statistics in Medicine, 9, pp. 469-485.</Item>
      <Item>Greenacre, M.J. (1993), Biplots in correspondence Analysis, Journal of Applied Statistics, 20, pp. 251 - 269.</Item>
      <Item>Urbano L.-S., van de Velden M., Kiers H.A.L. (2009), CAR: A MATLAB Package to Compute Correspondence Analysis with Rotations, Journal of Statistical Software, Volume 31, Issue 8.</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>crosstab</Item>
      <Item>rcontFS</Item>
      <Item>CressieRead</Item>
      <Item>CorAnaplot</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>CorAna with all the default options.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>load smoke</ItemCell>
            <ItemCell>[N,~,~,labels] =crosstab(smoke.data(:,1),smoke.data(:,2));</ItemCell>
            <ItemCell>[I,J]=size(N);</ItemCell>
            <ItemCell>if verLessThan('matlab','8.2.0')==0</ItemCell>
            <ItemCell>% Contingency table is supplied to CorAna in table format</ItemCell>
            <ItemCell>    Ntable=array2table(N,'RowNames',labels(1:I,1),'VariableNames',labels(1:J,2))</ItemCell>
            <ItemCell>    out=CorAna(Ntable);</ItemCell>
            <ItemCell>else</ItemCell>
            <ItemCell>    out=CorAna(N);</ItemCell>
            <ItemCell>end</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>CorAna with name pairs.</Title>
         <Desc>
            <ItemCell>Input is the contingency table, labels for rows and columns are supplied Data are read from the txt file</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>load('smoke.txt')</ItemCell>
            <ItemCell>labels_rows= {'Senior-Managers' 'Junior-Managers' 'Senior-Employees' 'Junior-Employees' 'Secretaries'};</ItemCell>
            <ItemCell>labels_columns= {'None' 'Light' 'Medium' 'Heavy'};</ItemCell>
            <ItemCell>N=crosstab(smoke(:,1),smoke(:,2));</ItemCell>
            <ItemCell>out=CorAna(N,'Lr',labels_rows,'Lc',labels_columns);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>CorAna with original data matrix as input.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>load smoke</ItemCell>
            <ItemCell>out=CorAna(smoke.data,'datamatrix',true);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>CorAna with supplementary rows and supplementary columns.</Title>
         <Desc>
            <ItemCell>Children data Active rows = 1:15 Active columns = 1:5</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>N=[51	64	32	29	17	59	66	70;</ItemCell>
            <ItemCell>53	90	78	75	22	115	117	86;</ItemCell>
            <ItemCell>71	111	50	40	11	79	88	177;</ItemCell>
            <ItemCell>1	7	5	5	4	9	8	5;</ItemCell>
            <ItemCell>7	11	4	3	2	2	17	18;</ItemCell>
            <ItemCell>7	13	12	11	11	18	19	17;</ItemCell>
            <ItemCell>21	37	14	26	9	14	34	61;</ItemCell>
            <ItemCell>12	35	19	6	7	21	30	28;</ItemCell>
            <ItemCell>10	7	7	3	1	8	12	8;</ItemCell>
            <ItemCell>4	7	7	6	2	7	6	13;</ItemCell>
            <ItemCell>8	22	7	10	5	10	27	17;</ItemCell>
            <ItemCell>25	45	38	38	13	48	59	52;</ItemCell>
            <ItemCell>18	27	20	19	9	13	29	53;</ItemCell>
            <ItemCell>35	61	29	14	12	30	63	58;</ItemCell>
            <ItemCell>2	4	3	1	4	nan  nan	nan	  ;</ItemCell>
            <ItemCell>2	8	2	5	2	nan  nan	nan;</ItemCell>
            <ItemCell>1	5	4	6	3	nan  nan	nan;</ItemCell>
            <ItemCell>3	3	1	3	4	nan  nan	nan];</ItemCell>
            <ItemCell>% rowslab = cell containing row labels</ItemCell>
            <ItemCell>rowslab={'money','future','unemployment','circumstances',...</ItemCell>
            <ItemCell>'hard','economic','egoism','employment','finances',...</ItemCell>
            <ItemCell>'war','housing','fear','health','work','comfort','disagreement',...</ItemCell>
            <ItemCell>'world','to_live'};</ItemCell>
            <ItemCell>% colslab = cell containing column labels</ItemCell>
            <ItemCell>colslab={'unqualified','cep','bepc','high_school_diploma','university',...</ItemCell>
            <ItemCell>'thirty','fifty','more_fifty'};</ItemCell>
            <ItemCell>tableN=array2table(N,'VariableNames',colslab,'RowNames',rowslab);</ItemCell>
            <ItemCell>% Extract just active rows and active columns</ItemCell>
            <ItemCell>Nactive=tableN(1:14,1:5);</ItemCell>
            <ItemCell>% Define tables containing supplementary rows and supplementary cols</ItemCell>
            <ItemCell>Nsupr=tableN(15:18,1:5);</ItemCell>
            <ItemCell>Nsupc=tableN(1:14,6:8);</ItemCell>
            <ItemCell>Sup=struct;</ItemCell>
            <ItemCell>Sup.r=Nsupr;</ItemCell>
            <ItemCell>Sup.c=Nsupc;</ItemCell>
            <ItemCell>out=CorAna(Nactive,'Sup',Sup);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
   </ExtraEx>
</HelpXML>