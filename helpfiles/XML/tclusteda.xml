<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->tclusteda</Title>
   <Purpose><!--This is the second line of the .m file-->tclusteda computes tclust for a series of values of the trimming factor
</Purpose>
   <Description><!--Description section-->tclusteda performs tclust for a series of values of the trimming factor alpha given k (number of groups) and given c (restriction factor). In order to increase the speed of the computations, parfor is used.
</Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>Y</Name>
         <ShortDesc>Input data.</ShortDesc>
         <TypeInd>Matrix.</TypeInd>
         <LongDesc>Data matrix containing n observations on v variables.
Rows of Y represent observations, and columns represent variables.
Missing values (NaN's) and infinite values (Inf's) are allowed, since observations (rows) with missing or infinite values will automatically be excluded from the computations.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>k</Name>
         <ShortDesc>Number of groups.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which specifies the number of groups.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>alpha</Name>
         <ShortDesc>trimming level to monitor.</ShortDesc>
         <TypeInd>Vector.</TypeInd>
         <LongDesc>Vector which specifies the values of trimming levels which have to be considered.
alpha is a vector which contains decresing elements which lie in the interval 0 and 0.5.
For example is alpha=[0.1 0.05 0] tclusteda considers these 3 values of trimming level.
If alpha=0 tclusteda reduces to traditional model based or mixture clustering (mclust): see Matlab function gmdistribution. The default for alpha is vector [0.1 0.05 0]. The sequence is forced to be monotonically decreasing.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrfactor</Name>
         <ShortDesc>Restriction factor.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Positive scalar which constrains the allowed differences among group scatters. Larger values imply larger differences of group scatters. On the other hand a value of 1 specifies the strongest restriction forcing all eigenvalues/determinants to be equal and so the method looks for similarly scattered (respectively spherical) clusters. The default is to apply restrfactor to eigenvalues. In order to apply restrfactor to determinants it is is necessary to use optional input argument restr.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>nsamp</Name>
         <ShortDesc>Number of subsamples to extract.</ShortDesc>
         <TypeInd>Scalar or matrix.</TypeInd>
         <LongDesc>If nsamp is a scalar it contains the number of subsamples which will be extracted. If nsamp=0 all subsets will be extracted.
Remark - if the number of all possible subset is &amp;lt;300 the default is to extract all subsets, otherwise just 300 If nsamp is a matrix it contains in the rows the indexes of the subsets which have to be extracted. nsamp in this case can be conveniently generated by function subsets. nsamp can have k columns or k*(v+1) columns. If nsamp has k columns the k initial centroids each iteration i are given by X(nsamp(i,:),:) and the covariance matrices are equal to the identity.
If nsamp has k*(v+1) columns the initial centroids and covariance matrices in iteration i are computed as follows:
X1=X(nsamp(i,:),:);
mean(X1(1:v+1,:)) contains the initial centroid for group 1;
cov(X1(1:v+1,:)) contains the initial cov matrix for group 1;
mean(X1(v+2:2*v+2,:)) contains the initial centroid for group 2;
cov((v+2:2*v+2,:)) contains the initial cov matrix for group 2;
...;
mean(X1((k-1)*v+1:k*(v+1))) contains the initial centroids for group k;
cov(X1((k-1)*v+1:k*(v+1))) contains the initial cov matrix for group k.
REMARK - if nsamp is not a scalar option option below startv1 is ignored. More precisely, if nsamp has k columns startv1=0 elseif nsamp has k*(v+1) columns option startv1 =1.</LongDesc>
         <Example>'nsamp',1000</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refsteps</Name>
         <ShortDesc>Number of refining iterations.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Number of refining iterations in each subsample. Default is 15.
refsteps = 0 means "raw-subsampling" without iterations.</LongDesc>
         <Example>'refsteps',10</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftol</Name>
         <ShortDesc>Tolerance for the refining steps.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>The default value is 1e-14;</LongDesc>
         <Example>'reftol',1e-05</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>equalweights</Name>
         <ShortDesc>Cluster weights in the concentration and assignment steps.</ShortDesc>
         <TypeInd>Logical.</TypeInd>
         <LongDesc>A logical value specifying whether cluster weights shall be considered in the concentration, assignment steps and computation of the likelihood.
if equalweights = true we are (ideally) assuming equally sized groups by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log f(x_i; m_j , S_j)
\]
else if equalweights = false (default) we allow for different group weights by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log \left[ \frac{n_j}{n} f(x_i; m_j , S_j) \right]=
\]
\[
= \sum_{j=1}^k n_j \log n_j/n + \sum_{j=1}^k \sum_{ x_i \in group_j} \log f(x_i; m_j , S_j) .
\]
Remark: $\sum_{j=1}^k n_j \log n_j/n$ is the so called entropy term</LongDesc>
         <Example>'equalweights',true</Example>
         <DataType>Logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>mixt</Name>
         <ShortDesc>Mixture modelling or crisp assignment.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Option mixt specifies whether mixture modelling or crisp assignment approach to model based clustering must be used.
In the case of mixture modelling parameter mixt also controls which is the criterion to find the untrimmed units in each step of the maximization.
If mixt &amp;gt;=1 mixture modelling is assumed else crisp assignment. The default value is mixt=0 (i.e. crisp assignment).
In mixture modelling the likelihood is given by:
\[
\prod_{i=1}^n \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j),
\]
while in crisp assignment the likelihood is given by:
\[
\prod_{j=1}^k \prod _{i\in R_j} \phi (y_i; \; \theta_j),
\]
where $R_j$ contains the indexes of the observations which are assigned to group $j$.
Remark - if mixt&amp;gt;=1 previous parameter equalweights is automatically set to 1.
Parameter mixt also controls the criterion to select the units to trim, if mixt = 2 the h units are those which give the largest contribution to the likelihood that is the h largest values of:
\[
\sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j) \qquad i=1, 2, ..., n,
\]
else if mixt=1 the criterion to select the h units is exactly the same as the one which is used in crisp assignment. That is: the n units are allocated to a cluster according to criterion:
\[
\max_{j=1, \ldots, k} \hat \pi'_j \phi (y_i; \; \hat \theta_j)
\]
and then these n numbers are ordered and the units associated with the largest h numbers are untrimmed.</LongDesc>
         <Example>'mixt',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen.</ShortDesc>
         <TypeInd>Scalar structure.</TypeInd>
         <LongDesc>Case 1: plots option used as scalar.
- If plots=0 (default), plots are not generated.
- If plots=1, two plots are shown on the screen.
The first plot ("monitor plot") shows three panels monitoring between two consecutive values of alpha the change in classification using ARI index (top panel), the change in centroids using squared euclidean distances (central panel), the change in covariance matrices using squared euclidean distance (bottom panel).
The second plot ("gscatter plot") shows a series of subplots which monitor the classification for each value of alpha. In order to make sure that consistent labels are used for the groups, between two consecutive values of alpha, we assign label r to a group if this group shows the smallest distance with group r for the previous value of alpha. The type of plot which is used to monitor the stability of the classification depends on the value of v.
* for v=1, we use histograms of the univariate data (function histFS is called).
* for v=2, we use the scatter plot of the two variables (function gscatter is called).
* for v&amp;gt;2, we use the scatter plot of the first two principal components (function gscatter is called and we show on the axes titles the percentage of variance explained by the first two principal components).
Case 2: plots option used as struct.
If plots is a structure it may contain the following fields:
plots.name = cell array of strings which enables to specify which plot to display. plots.name = {'gscatter'} produces a figure with a series of subplots which show the classification for each value of alpha. plots.name = {'monitor'} shows a figure with 3 panels which monitor between two consecutive values of alpha the change in classification using ARI index (top panel), the change in centroids using squared euclidean distances (central panel), the change in covariance matrices using squared euclidean distance (bottom panel). If this field is not specified plots.name={'gscatter' 'monitor'} and both figures will be shown.
plots.alphasel = numeric vector which speciies for which values of alpha it is possible to see the classification.
For example if plots.alphasel =[ 0.05 0.02], the classification will be shown just for alpha=0.05 and alpha=0.02; If this field is not specified plots.alphasel=alpha and therefore the classification is shown for each value of alpha.</LongDesc>
         <Example>'plots', 1</Example>
         <DataType>single | double | struct</DataType>
         <Struct>
            <ItemCell>
               <Value>name</Value>
               <Description>cell array of strings which enables to&#xD;
                   specify which plot to display. plots.name = {'gscatter'}&#xD;
                   produces a figure with a series of subplots which show the&#xD;
                   classification for each value of alpha. plots.name = {'monitor'}&#xD;
                   shows a figure with 3 panels which monitor between two&#xD;
                   consecutive values of alpha the change in classification&#xD;
                   using ARI index (top panel), the change in centroids&#xD;
                   using squared euclidean distances (central panel), the&#xD;
                   change in covariance matrices using squared euclidean&#xD;
                   distance (bottom panel). If this field is&#xD;
                   not specified plots.name={'gscatter' 'monitor'} and&#xD;
                   both figures will be shown.</Description>
            </ItemCell>
            <ItemCell>
               <Value>alphasel</Value>
               <Description>numeric vector which speciies for which&#xD;
                   values of alpha it is possible to see the classification.&#xD;
                   For example if plots.alphasel =[ 0.05 0.02], the&#xD;
                   classification will be shown just for alpha=0.05 and&#xD;
                   alpha=0.02; If this field is&#xD;
                   not specified plots.alphasel=alpha and therefore the&#xD;
                   classification is shown for each value of alpha.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>msg</Name>
         <ShortDesc>Level of output to display.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which controls whether to display or not messages on the screen.
If msg=0 nothing is displayed on the screen.
If msg=1 (default) messages are displayed on the screen about estimated time to compute the estimator or the number of subsets in which there was no convergence.
If msg=2 detailed messages are displayed. For example the information at iteration level.</LongDesc>
         <Example>'msg',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on matrix Y.
As default nocheck=0.</LongDesc>
         <Example>'nocheck',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>startv1</Name>
         <ShortDesc>How to initialize centroids and covariance matrices.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If startv1 is 1 then initial centroids and covariance matrices are based on (v+1) observations randomly chosen, else each centroid is initialized taking a random row of input data matrix and covariance matrices are initialized with identity matrices. The default value of startv1 is 1.
Remark 1 - in order to start with a routine which is in the required parameter space, eigenvalue restrictions are immediately applied.
Remark 2 - option startv1 is used just if nsamp is a scalar (see for more details the help associated with nsamp).</LongDesc>
         <Example>'startv1',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>RandNumbForNini</Name>
         <ShortDesc>Pre-extracted random numbers to initialize proportions.</ShortDesc>
         <TypeInd>Matrix.</TypeInd>
         <LongDesc>Matrix with size k-by-size(nsamp,1) containing the random numbers which are used to initialize the proportions of the groups. This option is effective just if nsamp is a matrix which contains pre-extracted subsamples. The purpose of this option is to enable to user to replicate the results in case routine tclust is called using a parfor instruction (as it happens for example in routine IC, where tclust is called through a parfor for different values of the restriction factor).
The default value of RandNumbForNini is empty that is random numbers from uniform are used.</LongDesc>
         <Example>'RandNumbForNini',''</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrtype</Name>
         <ShortDesc>type of restriction.</ShortDesc>
         <TypeInd>Character.</TypeInd>
         <LongDesc>The type of restriction to be applied on the cluster scatter matrices. Valid values are 'eigen' (default), or 'deter'.
eigen implies restriction on the eigenvalues while deter implies restriction on the determinants.</LongDesc>
         <Example>'restrtype','deter'</Example>
         <DataType>char</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>UnitsSameGroup</Name>
         <ShortDesc>list of the units which must (whenever possible) have a particular label.</ShortDesc>
         <TypeInd>Numeric vector.</TypeInd>
         <LongDesc>For example if UnitsSameGroup=[20 26], means that group which contains unit 20 is always labelled with number 1. Similarly, the group which contains unit 26 is always labelled with number 2, (unless it is found that unit 26 already belongs to group 1). In general, group which contains unit UnitsSameGroup(r) where r=2, ...length(kk)-1 is labelled with number r (unless it is found that unit UnitsSameGroup(r) has already been assigned to groups 1, 2, ..., r-1).</LongDesc>
         <Example>'UnitsSameGroup',[20 34]</Example>
         <DataType> integer vector</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>numpool</Name>
         <ShortDesc>The number of parallel sessions to open.</ShortDesc>
         <TypeInd>Integer.</TypeInd>
         <LongDesc>If numpool is not defined, then it is set equal to the number of physical cores in the computer.</LongDesc>
         <Example>'numpool',4</Example>
         <DataType> integer vector</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>cleanpool</Name>
         <ShortDesc>Function name.</ShortDesc>
         <TypeInd>Scalar {0,1}.</TypeInd>
         <LongDesc>Indicated if the open pool must be closed or not. It is useful to leave it open if there are subsequent parallel sessions to execute, so that to save the time required to open a new pool.</LongDesc>
         <Example>'cleanpool',true</Example>
         <DataType>integer | logical</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Structure>
            <ItemCell>
               <Value>IDX</Value>
               <Description>n-by-length(alpha) vector containing assignment of each unit to each of the k groups. Cluster names are integer numbers from 1 to k. 0 indicates trimmed observations. First column refers of out.IDX refers to alpha(1), second column of out.IDX refers to alpha(2), ..., last column refers to alpha(end).</Description>
            </ItemCell>
            <ItemCell>
               <Value>MU</Value>
               <Description>3D array of size k-by-v-by-length(alpha) containing the monitoring of the centroid for each value of alpha. out.MU(:,:,1), refers to alpha(1) ..., out.MU(:,:,end) refers to alpha(end). First row in each slice refers to group 1, second row refers to group 2 ...</Description>
            </ItemCell>
            <ItemCell>
               <Value>SIGMA</Value>
               <Description>cell of length length(alpha) containing in element j, with j=1, 2, ..., length(alpha), the 3D array of size v-by-v-k containing the k (constrained) estimated covariance matrices associated with alpha(j).</Description>
            </ItemCell>
            <ItemCell>
               <Value>Amon</Value>
               <Description>Amon stands for alpha monitoring. Matrix of size (length(alpha)-1)-by-4 which contains for two consecutive values of alpha the monitoring of three quantities (change in classification, change in centroid location, change in covariance location).
1st col = value of alpha.
2nd col = ARI index.
3rd col = squared Euclidean distance between centroids.
4th col = squared Euclidean distance between covariance matrices.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Y</Value>
               <Description>Original data matrix Y.</Description>
            </ItemCell>
         </Structure>
      </Item>
      <Item>
         <Name>varargout</Name>
         <ShortDesc>outcell : cell of length length(alpha)</ShortDesc>
         <TypeInd>In jth position the structure which comes out from procedure tclust applied to alpha(j), with j =1, 2, .</TypeInd>
         <LongDesc>.., length(alpha).</LongDesc>
         <Structure> </Structure>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->This procedure extends to tclust the so called monitoring approach. The phylosophy is to investigate how the results change as the trimming proportion alpha reduces. This function enables us to monitor the change in classification (measured by the ARI index) and the change in centroids and covariance matrices (measured by the squared euclidean distances). In order to make sure that consistent labels are used for the groups, between two consecutive values of alpha, we assign label r to a group if this group shows the smallest distance with group r for the previous value of alpha.
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Garcia-Escudero, L.A., Gordaliza, A., Matran, C. and Mayo-Iscar, A. (2008), A General Trimming Approach to Robust Cluster Analysis. Annals of Statistics, Vol.36, 1324-1345.
Technical Report available at:
http://www.eio.uva.es/inves/grupos/representaciones/trTCLUST.pdf</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>tclust</Item>
      <Item>tclustIC</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>Monitoring using geyser data (all default options).</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>% alpha and restriction factor are not specified therefore for alpha</ItemCell>
            <ItemCell>% vector [0.10 0.05 0] is used while for the restriction factor, value c=12</ItemCell>
            <ItemCell>% is used</ItemCell>
            <ItemCell>k=3;</ItemCell>
            <ItemCell>[out]=tclusteda(Y,k);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Monitoring using geyser data with alpha and c specified.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% alphavec= vector which contains the trimming levels to consider</ItemCell>
            <ItemCell>alphavec=0.10:-0.01:0;</ItemCell>
            <ItemCell>% c = restriction factor to use</ItemCell>
            <ItemCell>c=100;</ItemCell>
            <ItemCell>% k= number of groups</ItemCell>
            <ItemCell>k=3;</ItemCell>
            <ItemCell>[out]=tclusteda(Y,k,alphavec,c);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Monitoring using geyser data with option plots supplied as structure.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% alphavec= vector which contains the trimming levels to consider</ItemCell>
            <ItemCell>% in this case 31 values of alpha are considered</ItemCell>
            <ItemCell>alphavec=0.30:-0.01:0;</ItemCell>
            <ItemCell>% c = restriction factor to use</ItemCell>
            <ItemCell>c=100;</ItemCell>
            <ItemCell>% k= number of groups</ItemCell>
            <ItemCell>k=3;</ItemCell>
            <ItemCell>% The monitoring plot of allocation will shows just these four values of</ItemCell>
            <ItemCell>% alpha</ItemCell>
            <ItemCell>plots=struct;</ItemCell>
            <ItemCell>plots.alphasel=[0.2 0.10 0.05 0.01];</ItemCell>
            <ItemCell>[out]=tclusteda(Y,k,alphavec,c,'plots',plots);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>Monitoring geyser data with option UnitsSameGroup.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% alphavec= vector which contains the trimming levels to consider</ItemCell>
            <ItemCell>% in this case 31 values of alpha are considered</ItemCell>
            <ItemCell>alphavec=0.30:-0.10:0;</ItemCell>
            <ItemCell>% c = restriction factor to use</ItemCell>
            <ItemCell>c=100;</ItemCell>
            <ItemCell>% k= number of groups</ItemCell>
            <ItemCell>k=3;</ItemCell>
            <ItemCell>% Make sure that group containing unit 10 is in a group which is labelled</ItemCell>
            <ItemCell>% group 1 and group containing unit 12 is in group which is labelled group 2</ItemCell>
            <ItemCell>UnitsSameGroup=[10 12];</ItemCell>
            <ItemCell>% Mixture model is used</ItemCell>
            <ItemCell>mixt=2;</ItemCell>
            <ItemCell>[out]=tclusteda(Y,k,alphavec,1000,'mixt',2,'UnitsSameGroup',UnitsSameGroup);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclusteda with M5 data.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('M5data.txt');</ItemCell>
            <ItemCell>% alphavec= vector which contains the trimming levels to consider</ItemCell>
            <ItemCell>% in this case 31 values of alpha are considered</ItemCell>
            <ItemCell>alphavec=0.10:-0.02:0;</ItemCell>
            <ItemCell>out=tclusteda(Y(:,1:2),3,alphavec,1000,'nsamp',1000,'plots',1);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Structured noise data ex1.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('structurednoise.txt');</ItemCell>
            <ItemCell>alphavec=0.20:-0.01:0;</ItemCell>
            <ItemCell>out=tclusteda(Y,2,alphavec,100,'plots',1);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Structured noise data ex2.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('structurednoise.txt');</ItemCell>
            <ItemCell>alphavec=0.20:-0.01:0;</ItemCell>
            <ItemCell>% just show the monitoring plot</ItemCell>
            <ItemCell>plots=struct;</ItemCell>
            <ItemCell>plots.name = {'monitor'};</ItemCell>
            <ItemCell>out=tclusteda(Y,2,alphavec,100,'plots',plots);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>mixture100 data.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('mixture100.txt');</ItemCell>
            <ItemCell>% Traditional tclust</ItemCell>
            <ItemCell>alphavec=0.20:-0.01:0;</ItemCell>
            <ItemCell>% just show the allocation plot</ItemCell>
            <ItemCell>plots=struct;</ItemCell>
            <ItemCell>plots.name = {'gscatter'};</ItemCell>
            <ItemCell>out=tclusteda(Y,2,alphavec,100,'plots',plots);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclusteda using simulated data.</Title>
         <Desc>
            <ItemCell>5 groups and 5 variables</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>rng(100,'twister')</ItemCell>
            <ItemCell>n1=100;</ItemCell>
            <ItemCell>n2=80;</ItemCell>
            <ItemCell>n3=50;</ItemCell>
            <ItemCell>n4=80;</ItemCell>
            <ItemCell>n5=70;</ItemCell>
            <ItemCell>v=5;</ItemCell>
            <ItemCell>Y1=randn(n1,v)+5;</ItemCell>
            <ItemCell>Y2=randn(n2,v)+3;</ItemCell>
            <ItemCell>Y3=rand(n3,v)-2;</ItemCell>
            <ItemCell>Y4=rand(n4,v)+2;</ItemCell>
            <ItemCell>Y5=rand(n5,v);</ItemCell>
            <ItemCell>group=ones(n1+n2+n3+n4+n5,1);</ItemCell>
            <ItemCell>group(n1+1:n1+n2)=2;</ItemCell>
            <ItemCell>group(n1+n2+1:n1+n2+n3)=3;</ItemCell>
            <ItemCell>group(n1+n2+n3+1:n1+n2+n3+n4)=4;</ItemCell>
            <ItemCell>group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=[Y1;Y2;Y3;Y4;Y5];</ItemCell>
            <ItemCell>n=size(Y,1);</ItemCell>
            <ItemCell>% Set number of groups</ItemCell>
            <ItemCell>k=5;</ItemCell>
            <ItemCell>% Example of the subsets precalculated</ItemCell>
            <ItemCell>nsamp=2000;</ItemCell>
            <ItemCell>nsampscalar=nsamp;</ItemCell>
            <ItemCell>nsamp=subsets(nsamp,n,(v+1)*k);</ItemCell>
            <ItemCell>% Random numbers to compute proportions computed once and for all</ItemCell>
            <ItemCell>RandNumbForNini=rand(k,nsampscalar);</ItemCell>
            <ItemCell>% The allocation is shown on the space of the first two principal</ItemCell>
            <ItemCell>% components</ItemCell>
            <ItemCell>out=tclusteda(Y,k,[],6,'plots',1,'RandNumbForNini',RandNumbForNini,'nsamp',nsamp);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclusteda using determinant constraint.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>out=tclusteda(Y,k,[],1000,'plots',1,'restrtype','deter');</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>