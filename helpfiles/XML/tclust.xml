<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->tclust</Title>
   <Purpose><!--This is the second line of the .m file-->tclust computes trimmed clustering with scatter restrictions
</Purpose>
   <Description><!--Description section-->tclust partitions the points in the n-by-v data matrix Y into k clusters. We are very happy to be in Mathworks. This partition minimizes the trimmed sum, over all clusters, of the within-cluster sums of point-to-cluster-centroid distances. Rows of Y correspond to points, columns correspond to variables. tclust returns inside structure out an n-by-1 vector idx containing the cluster indices of each point. By default, tclust uses (squared), possibly constrained, Mahalanobis distances.
</Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>Y</Name>
         <ShortDesc>Input data.</ShortDesc>
         <TypeInd>Matrix.</TypeInd>
         <LongDesc>Data matrix containing n observations on v variables.
Rows CIAO CIAO of Y represent observations, and columns represent variables.
Missing values (NaN's) and infinite values (Inf's) are allowed, since observations (rows) with missing or infinite values will automatically be excluded from the computations.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>k</Name>
         <ShortDesc>Number of groups.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which specifies the number of groups.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>alpha</Name>
         <ShortDesc>Global trimming level IN MATHWORKS.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>alpha is a scalar between 0 and 0.5 or an integer specifying the number of observations which have to be trimmed. If alpha=0 tclust reduces to traditional model based or mixture clustering (mclust): see Matlab function gmdistribution.
More in detail, if 0&amp;lt; alpha &amp;lt;1 clustering is based on h=fix(n*(1-alpha)) observations, else if alpha is an integer greater than 1 clustering is based on h=n-floor(alpha);</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrfactor</Name>
         <ShortDesc>Restriction factor.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Positive scalar which constrains the allowed differences among group scatters. Larger values imply larger differences of group scatters. On the other hand a value of 1 specifies the strongest restriction forcing all eigenvalues/determinants to be equal and so the method looks for similarly scattered (respectively spherical) clusters. The default is to apply restrfactor to eigenvalues. In order to apply restrfactor to determinants it is is necessary to use optional input argument restr.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>nsamp</Name>
         <ShortDesc>Number of subsamples to extract.</ShortDesc>
         <TypeInd>Scalar or matrix.</TypeInd>
         <LongDesc>If nsamp is a scalar it contains the number of subsamples which will be extracted. If nsamp=0 all subsets will be extracted.
Remark - if the number of all possible subset is &amp;lt;300 the default is to extract all subsets, otherwise just 300 If nsamp is a matrix it contains in the rows the indexes of the subsets which have to be extracted. nsamp in this case can be conveniently generated by function subsets. nsamp can have k columns or k*(v+1) columns. If nsamp has k columns the k initial centroids each iteration i are given by X(nsamp(i,:),:) and the covariance matrices are equal to the identity.
If nsamp has k*(v+1) columns the initial centroids and covariance matrices in iteration i are computed as follows:
X1=X(nsamp(i,:),:);
mean(X1(1:v+1,:)) contains the initial centroid for group 1;
cov(X1(1:v+1,:)) contains the initial cov matrix for group 1;
mean(X1(v+2:2*v+2,:)) contains the initial centroid for group 2;
cov((v+2:2*v+2,:)) contains the initial cov matrix for group 2;
...;
mean(X1((k-1)*v+1:k*(v+1))) contains the initial centroids for group k;
cov(X1((k-1)*v+1:k*(v+1))) contains the initial cov matrix for group k.
REMARK - if nsamp is not a scalar option option below startv1 is ignored. More precisely, if nsamp has k columns startv1=0 elseif nsamp has k*(v+1) columns option startv1 =1.</LongDesc>
         <Example>'nsamp',1000</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refsteps</Name>
         <ShortDesc>Number of refining iterations.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Number of refining iterations in each subsample. Default is 15.
refsteps = 0 means "raw-subsampling" without iterations.</LongDesc>
         <Example>'refsteps',10</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftol</Name>
         <ShortDesc>Tolerance for the refining steps.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>The default value is 1e-14;</LongDesc>
         <Example>'reftol',1e-05</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>equalweights</Name>
         <ShortDesc>Cluster weights in the concentration and assignment steps.</ShortDesc>
         <TypeInd>Logical.</TypeInd>
         <LongDesc>A logical value specifying whether cluster weights shall be considered in the concentration, assignment steps and computation of the likelihood.
if equalweights = true we are (ideally) assuming equally sized groups by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log f(x_i; m_j , S_j)
\]
else if equalweights = false (default) we allow for different group weights by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log \left[ \frac{n_j}{n} f(x_i; m_j , S_j) \right]=
\]
\[
= \sum_{j=1}^k n_j \log n_j/n + \sum_{j=1}^k \sum_{ x_i \in group_j} \log f(x_i; m_j , S_j) .
\]
Remark: $\sum_{j=1}^k n_j \log n_j/n$ is the so PIeter called entropy term</LongDesc>
         <Example>'equalweights',true</Example>
         <DataType>Logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>mixt</Name>
         <ShortDesc>Mixture modelling or crisp assignment.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Option mixt specifies whether mixture modelling or crisp assignment approach to model based clustering must be used.
In the case of mixture modelling parameter mixt also controls which is the criterion to find the untrimmed units in each step of the maximization.
If mixt &amp;gt;=1 mixture modelling is assumed else crisp assignment. The default value is mixt=0 (i.e. crisp assignment).
In mixture modelling the likelihood is given by:
\[
\prod_{i=1}^n \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j),
\]
while in crisp assignment the likelihood is given by:
\[
\prod_{j=1}^k \prod _{i\in R_j} \phi (y_i; \; \theta_j),
\]
where $R_j$ contains the indexes of the observations which are assigned to group $j$.
Remark - if mixt&amp;gt;=1 previous parameter equalweights is automatically set to 1.
Parameter mixt also controls the criterion to select the units to trim, if mixt = 2 the h units are those which give the largest contribution to the likelihood that is the h largest values of:
\[
\sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j) \qquad i=1, 2, ..., n,
\]
else if mixt=1 the criterion to select the h units is exactly the same as the one which is used in crisp assignment. That is: the n units are allocated to a cluster according to criterion:
\[
\max_{j=1, \ldots, k} \hat \pi'_j \phi (y_i; \; \hat \theta_j)
\]
and then these n numbers are ordered and the units associated with the largest h numbers are untrimmed.</LongDesc>
         <Example>'mixt',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen.</ShortDesc>
         <TypeInd>Scalar or character or structure.</TypeInd>
         <LongDesc>Case 1: plots option used as scalar.
- If plots=0 (default), plots are not generated.
- If plots=1, a plot with the classification is shown on the screen (using the spmplot function). The plot can be:
* for v=1, an histogram of the univariate data.
* for v=2, a bivariate scatterplot.
* for v&amp;gt;2, a scatterplot matrix generated by spmplot.
When v&amp;gt;=2 plots offers the following additional features (for v=1 the behaviour is forced to be as for plots=1):
Case 2: plots option used as character array.
- plots='contourf' adds in the background of the bivariate scatterplots a filled contour plot. The colormap of the filled contour is based on grey levels as default.
This argument may also be inserted in a field named 'type' of a structure. In the latter case it is possible to specify the additional field 'cmap', which changes the default colors of the color map used. The field 'cmap' may be a three-column matrix of values in the range [0,1] where each row is an RGB triplet that defines one color.
Check the colormap function for additional informations.
- plots='contour' adds in the background of the bivariate scatterplots a contour plot. The colormap of the contour is based on grey levels as default. This argument may also be inserted in a field named 'type' of a structure.
In the latter case it is possible to specify the additional field 'cmap', which changes the default colors of the color map used. The field 'cmap' may be a three-column matrix of values in the range [0,1] where each row is an RGB triplet that defines one color.
Check the colormap function for additional informations.
- plots='ellipse' superimposes confidence ellipses to each group in the bivariate scatterplots. The size of the ellipse is chi2inv(0.95,2), i.e. the confidence level used by default is 95%. This argument may also be inserted in a field named 'type' of a structure. In the latter case it is possible to specify the additional field 'conflev', which specifies the confidence level to use and it is a value between 0 and 1.
- plots='boxplotb' superimposes on the bivariate scatterplots the bivariate boxplots for each group, using the boxplotb function. This argument may also be inserted in a field named 'type' of a structure.
Case 3: plots option used as struct.
If plots is a structure it may contain the following fields:
plots.type = in this case the 'type' supplied is used to set the type of plot as when plots option is a character array. Therefore, plots.type can be:
'contourf', 'contour', 'ellipse' or 'boxplotb'.
plots.cmap = this field is used to set a colormap for the plot type. For example, plots.cmap = 'autumn'.
See the MATLAB help of colormap for a list of colormap possiblilites.
plots.conflev = this is the confidence level for the confidence ellipses. It must me a scalar between 0 and 1. For example, one can set:
plots.type = 'ellipse';
plots.conflev = 0.5;
REMARK - The labels=0 are automatically excluded from the overlaying phase, considering them as outliers.</LongDesc>
         <Example>'plots', 1</Example>
         <DataType>single | double | character | struct</DataType>
         <Struct>
            <ItemCell>
               <Value>type</Value>
               <Description>in this case the 'type' supplied &#xD;
                 is used to set the type of plot as when plots option is&#xD;
                 a character array. Therefore, plots.type can be:&#xD;
                 'contourf', 'contour', 'ellipse' or 'boxplotb'.</Description>
            </ItemCell>
            <ItemCell>
               <Value>cmap</Value>
               <Description>this field is used to set a colormap&#xD;
                 for the plot type. For example, plots.cmap = 'autumn'.&#xD;
                 See the MATLAB help of colormap for a list of colormap&#xD;
                 possiblilites.</Description>
            </ItemCell>
            <ItemCell>
               <Value>conflev</Value>
               <Description>this is the confidence level&#xD;
                 for the confidence ellipses. It must me a scalar between&#xD;
                 0 and 1. For example, one can set:&#xD;
                 plots.type = 'ellipse';&#xD;
                 plots.conflev = 0.5;</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>msg</Name>
         <ShortDesc>Level of output to display.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which controls whether to display or not messages on the screen.
If msg=0 nothing is displayed on the screen.
If msg=1 (default) messages are displayed on the screen about estimated time to compute the estimator or the number of subsets in which there was no convergence.
If msg=2 detailed messages are displayed. For example the information at iteration level.</LongDesc>
         <Example>'msg',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on matrix Y.
As default nocheck=0.</LongDesc>
         <Example>'nocheck',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>startv1</Name>
         <ShortDesc>How to initialize centroids and covariance matrices.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If startv1 is 1 then initial centroids and covariance matrices are based on (v+1) observations randomly chosen, else each centroid is initialized taking a random row of input data matrix and covariance matrices are initialized with identity matrices. The default value of startv1 is 1.
Remark 1 - in order to start with a routine which is in the required parameter space, eigenvalue restrictions are immediately applied.
Remark 2 - option startv1 is used just if nsamp is a scalar (see for more details the help associated with nsamp).</LongDesc>
         <Example>'startv1',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>RandNumbForNini</Name>
         <ShortDesc>Pre-extracted random numbers to initialize proportions.</ShortDesc>
         <TypeInd>Matrix.</TypeInd>
         <LongDesc>Matrix with size k-by-size(nsamp,1) containing the random numbers which are used to initialize the proportions of the groups. This option is effective just if nsamp is a matrix which contains pre-extracted subsamples. The purpose of this option is to enable to user to replicate the results in case routine tclust is called using a parfor instruction (as it happens for example in routine IC, where tclust is called through a parfor for different values of the restriction factor).
The default value of RandNumbForNini is empty that is random numbers from uniform are used.</LongDesc>
         <Example>'RandNumbForNini',''</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrtype</Name>
         <ShortDesc>type of restriction.</ShortDesc>
         <TypeInd>Character.</TypeInd>
         <LongDesc>The type of restriction to be applied on the cluster scatter matrices. Valid values are 'eigen' (default), or 'deter'.
eigen implies restriction on the eigenvalues while deter implies restriction on the determinants.</LongDesc>
         <Example>'restrtype','deter'</Example>
         <DataType>char</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Ysave</Name>
         <ShortDesc>Save original input matrix.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Set Ysave to 1 to request that the input matrix Y is saved into the output structure out. Default is 0, id est no saving is done.</LongDesc>
         <Example>'Ysave',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Structure>
            <ItemCell>
               <Value>muopt</Value>
               <Description>k-by-v matrix containing cluster centroid locations. Robust estimate of final centroids of the groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>sigmaopt</Value>
               <Description>v-by-v-by-k array containing estimated constrained covariance for the k groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>idx</Value>
               <Description>n-by-1 vector containing assignment of each unit to each of the k groups. Cluster names are integer numbers from 1 to k. 0 indicates trimmed observations.</Description>
            </ItemCell>
            <ItemCell>
               <Value>siz</Value>
               <Description>Matrix of size (k+1)-by-3.
1st col = sequence from 0 to k;
2nd col = number of observations in each cluster;
3rd col = percentage of observations in each cluster;
Remark: 0 denotes unassigned units.</Description>
            </ItemCell>
            <ItemCell>
               <Value>postprob</Value>
               <Description>n-by-k matrix containing posterior probabilities out.postprob(i,j) contains posterior probabilitiy of unit i from component (cluster) j. For the trimmed units posterior probabilities are 0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>emp</Value>
               <Description>"Empirical" statistics computed on final classification.
Scalar or structure. When convergence is reached, out.emp=0. When convergence is not obtained, this field is a structure which contains the statistics of interest: idxemp (ordered from 0 to k*, k* being the number of groups with at least one observation and 0 representing the possible group of outliers), muemp, sigmaemp and sizemp, which are the empirical counterparts of idx, muopt, sigmaopt and siz.</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXMIX</Value>
               <Description>BIC which uses parameters estimated using the mixture loglikelihood and the maximized mixture likelihood as goodness of fit measure.
Remark: this output is present just if input option mixt is &amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXCLA</Value>
               <Description>BIC which uses the classification likelihood based on parameters estimated using the mixture likelihood (In some books this quantity is called ICL).
Remark: this output is present just if input option mixt is &amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>CLACLA</Value>
               <Description>BIC which uses the classification likelihood based on parameters estimated using the classification likelihood.
Remark: this output is present just if input option mixt is =0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>notconver</Value>
               <Description>Scalar. Number of subsets without convergence</Description>
            </ItemCell>
            <ItemCell>
               <Value>bs</Value>
               <Description>k-by-1 vector containing the units forming initial subset associated with muopt.</Description>
            </ItemCell>
            <ItemCell>
               <Value>obj</Value>
               <Description>Scalar. Value of the objective function which is minimized (value of the best returned solution).
If input option mixt &amp;gt;1 the likelihood which is maximized is a mixture likelihood as follows:
\[
\prod_{i=1}^h \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j),
\]
else the likelihood which is maximized is a classification likelihood of the the form:
\[
\prod_{j=1}^k \prod _{i\in R_j} \pi_j' \phi (y_i; \; \theta_j),
\]
where $R_j$ contains the indexes of the observations which are assigned to group $j$ with the constraint that $\# \bigcup_{j=1}^k R_j=h$. In the classification likelihood if input option equalweights is set to 0, then $\pi_j'=1$, $j=1, ..., k$.</Description>
            </ItemCell>
            <ItemCell>
               <Value>equalweights</Value>
               <Description>Logical. It is true if in the clustering procedure we (ideally) assumed equal cluster weights else it is false if we allowed for different cluster sizes.</Description>
            </ItemCell>
            <ItemCell>
               <Value>h</Value>
               <Description>Scalar. Number of observations that have determined the centroids (number of untrimmed units).</Description>
            </ItemCell>
            <ItemCell>
               <Value>fullsol</Value>
               <Description>Column vector of size nsamp which contains the value of the objective function at the end of the iterative process for each extracted subsample.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Y</Value>
               <Description>Original data matrix Y. The field is present if option Ysave is set to 1.</Description>
            </ItemCell>
         </Structure>
      </Item>
      <Item>
         <Name>varargout</Name>
         <ShortDesc>Matrix</ShortDesc>
         <TypeInd>C : Indexes of extracted subsamples.</TypeInd>
         <LongDesc>Matrix of size nsamp-by-(v+1)*k containing (in the rows) the indices of the subsamples extracted for computing the estimate.</LongDesc>
         <Structure> </Structure>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->This iterative algorithm initializes k clusters randomly and performs concentration steps in order to improve the current cluster assignment.
The number of maximum concentration steps to be performed is given by input parameter refsteps. For approximately obtaining the global optimum, the system is initialized nsamp times and concentration steps are performed until convergence or refsteps is reached. When processing more complex data sets higher values of nsamp and refsteps have to be specified (obviously implying extra computation time). However, if more then 10 per cent of the iterations do not converge, a warning message is issued, indicating that nsamp has to be increased.
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Garcia-Escudero, L.A., Gordaliza, A., Matran, C. and Mayo-Iscar, A. (2008), A General Trimming Approach to Robust Cluster Analysis. Annals of Statistics, Vol.36, 1324-1345.
Technical Report available at:
http://www.eio.uva.es/inves/grupos/representaciones/trTCLUST.pdf</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>tkmeans</Item>
      <Item>tclustIC</Item>
      <Item>tclusteda</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data using k=3, alpha=0.1 and restrfactor=10000.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Use of 'plots' option as a struct, to produce more complex plots.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',1);</ItemCell>
            <ItemCell>title('plot with all default options','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% default confidence ellipses.</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots','ellipse');</ItemCell>
            <ItemCell>title('default confidence ellipses','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% confidence ellipses specified by the user</ItemCell>
            <ItemCell>plots.type = 'ellipse';</ItemCell>
            <ItemCell>plots.conflev = 0.5;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',plots);</ItemCell>
            <ItemCell>title('confidence ellipses set to 0.5','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>plots.conflev = 0.9;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',plots);</ItemCell>
            <ItemCell>title('confidence ellipses set to 0.9','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% contour plots.</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots','contour');</ItemCell>
            <ItemCell>title('contour plot','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% filled contour plots with additional options</ItemCell>
            <ItemCell>plots.type = 'contourf';</ItemCell>
            <ItemCell>plots.cmap = autumn;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',plots);</ItemCell>
            <ItemCell>title('contourf plot with autumn colormap','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclust of geyser with varargout.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>nsamp=20;</ItemCell>
            <ItemCell>[out,MatrixContSubsets]=tclust(Y,3,0.1,10000,'nsamp',nsamp);</ItemCell>
            <ItemCell>% MatrixContSubsets is a matrix containing in the rows the indexes of</ItemCell>
            <ItemCell>% the nsamp subsets which have been extracted</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data (output comparison).</Title>
         <Desc>
            <ItemCell>We compare the output using three different values of restriction factor.</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>restrfactor=10000;</ItemCell>
            <ItemCell>% nsamp = number of subsamples which will be extracted</ItemCell>
            <ItemCell>nsamp=500;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'plots','ellipse');</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor)],'interpreter','LaTex','FontSize',18)</ItemCell>
            <ItemCell>restrfactor=10;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots','ellipse');</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor)],'interpreter','LaTex','FontSize',18)</ItemCell>
            <ItemCell>% trimmed k-means solution restrfactor=1</ItemCell>
            <ItemCell>restrfactor=1;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots','ellipse');</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor) '. Trimmed k-means solution'],'interpreter','LaTex','FontSize',18)</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the M5data.</Title>
         <Desc>
            <ItemCell>A bivariate data set obtained from three normal bivariate distributions with different scales and proportions 1:2:2. One of the components is very overlapped with another one. A 10 per cent background noise is added uniformly distributed in a rectangle containing the three normal components and not very overlapped with the three mixture components. A precise description of the M5 data set can be found in Garcia-Escudero et al. (2008).</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('M5data.txt');</ItemCell>
            <ItemCell>% plot(Y(:,1),Y(:,2),'o')</ItemCell>
            <ItemCell>% Scatter plot matrix with univariate boxplot on the main diagonal</ItemCell>
            <ItemCell>spmplot(Y(:,1:2),Y(:,3),[],'box')</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0,1000,'nsamp',100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0,10,'nsamp',100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.1,1,'nsamp',1000,'plots',1,'equalweights',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.1,1000,'nsamp',100,'plots',1)</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust in presence of structured noise.</Title>
         <Desc>
            <ItemCell>The data have been generated using the following R instructions set.seed (0) v &amp;lt;- runif (100, -2 * pi, 2 * pi) noise &amp;lt;- cbind (100 + 25 * sin (v), 10 + 5 * v) x &amp;lt;- rbind ( rmvnorm (360, c (0.0, 0), matrix (c (1, 0, 0, 1), ncol = 2)), rmvnorm (540, c (5.0, 10), matrix (c (6, -2, -2, 6), ncol = 2)), noise)</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('structurednoise.txt');</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),2,0.1,100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),5,0.15,1,'plots',1)</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data.</Title>
         <Desc>
            <ItemCell>The data have been generated using the following R instructions set.seed (100) mixt &amp;lt;- rbind (rmvnorm (360, c ( 0, 0), matrix (c (1, 0, 0, 1), ncol = 2)), rmvnorm (540, c ( 5, 10), matrix (c (6, -2, -2, 6), ncol = 2)), rmvnorm (100, c (2.5, 5), matrix (c (50, 0, 0, 50), ncol = 2)))</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('mixture100.txt');</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.05,1,'refsteps',20,'plots',1)</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data, comparison of different options.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('mixture100.txt');</ItemCell>
            <ItemCell>% Traditional tclust</ItemCell>
            <ItemCell>out1=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)</ItemCell>
            <ItemCell>title('Traditional tclust','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% tclust with mixture models (selection of untrimmed units according to</ItemCell>
            <ItemCell>% likelihood contributions</ItemCell>
            <ItemCell>out2=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',1)</ItemCell>
            <ItemCell>title('tclust with mixture models (likelihood contributions)','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>% Tclust with mixture models (selection of untrimmed units according to</ItemCell>
            <ItemCell>% densities weighted by estimates of the probability of the components)</ItemCell>
            <ItemCell>out3=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',2)</ItemCell>
            <ItemCell>title('tclust with mixture models (probability of the components)','interpreter','LaTex','FontSize',18);</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust using simulated data.</Title>
         <Desc>
            <ItemCell>5 groups and 5 variables</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>n1=100;</ItemCell>
            <ItemCell>n2=80;</ItemCell>
            <ItemCell>n3=50;</ItemCell>
            <ItemCell>n4=80;</ItemCell>
            <ItemCell>n5=70;</ItemCell>
            <ItemCell>v=5;</ItemCell>
            <ItemCell>Y1=randn(n1,v)+5;</ItemCell>
            <ItemCell>Y2=randn(n2,v)+3;</ItemCell>
            <ItemCell>Y3=rand(n3,v)-2;</ItemCell>
            <ItemCell>Y4=rand(n4,v)+2;</ItemCell>
            <ItemCell>Y5=rand(n5,v);</ItemCell>
            <ItemCell>group=ones(n1+n2+n3+n4+n5,1);</ItemCell>
            <ItemCell>group(n1+1:n1+n2)=2;</ItemCell>
            <ItemCell>group(n1+n2+1:n1+n2+n3)=3;</ItemCell>
            <ItemCell>group(n1+n2+n3+1:n1+n2+n3+n4)=4;</ItemCell>
            <ItemCell>group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=[Y1;Y2;Y3;Y4;Y5];</ItemCell>
            <ItemCell>out=tclust(Y,5,0.05,1.3,'refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for geyser data.</Title>
         <Desc>
            <ItemCell>close all</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>maxk=6;</ItemCell>
            <ItemCell>CLACLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>    out=tclust(Y,j,0.1,5,'msg',0);</ItemCell>
            <ItemCell>    CLACLA(j,2)=out.CLACLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>MIXCLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>MIXMIX=MIXCLA;</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>    out=tclust(Y,j,0.1,5,'mixt',2,'msg',0);</ItemCell>
            <ItemCell>    MIXMIX(j,2)=out.MIXMIX;</ItemCell>
            <ItemCell>    MIXCLA(j,2)=out.MIXCLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,1)</ItemCell>
            <ItemCell>plot(CLACLA(:,1),CLACLA(:,2))</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('CLACLA')</ItemCell>
            <ItemCell>subplot(1,3,2)</ItemCell>
            <ItemCell>plot(MIXMIX(:,1),MIXMIX(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXMIX')</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,3)</ItemCell>
            <ItemCell>plot(MIXCLA(:,1),MIXCLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXCLA (ICL)')</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for simulated data with k=5 and v=5.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>n1=100;     % Generate 5 groups in 5 dimensions</ItemCell>
            <ItemCell>n2=80;</ItemCell>
            <ItemCell>n3=50;</ItemCell>
            <ItemCell>n4=80;</ItemCell>
            <ItemCell>n5=70;</ItemCell>
            <ItemCell>v=5;</ItemCell>
            <ItemCell>Y1=randn(n1,v)+5;</ItemCell>
            <ItemCell>Y2=randn(n2,v)+3;</ItemCell>
            <ItemCell>Y3=rand(n3,v)-2;</ItemCell>
            <ItemCell>Y4=rand(n4,v)+2;</ItemCell>
            <ItemCell>Y5=rand(n5,v);</ItemCell>
            <ItemCell>group=ones(n1+n2+n3+n4+n5,1);</ItemCell>
            <ItemCell>group(n1+1:n1+n2)=2;</ItemCell>
            <ItemCell>group(n1+n2+1:n1+n2+n3)=3;</ItemCell>
            <ItemCell>group(n1+n2+n3+1:n1+n2+n3+n4)=4;</ItemCell>
            <ItemCell>group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;</ItemCell>
            <ItemCell>Y=[Y1;Y2;Y3;Y4;Y5];</ItemCell>
            <ItemCell>restrfactor=5;</ItemCell>
            <ItemCell>maxk=7;</ItemCell>
            <ItemCell>CLACLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>    out=tclust(Y,j,0.1,restrfactor);</ItemCell>
            <ItemCell>    CLACLA(j,2)=out.CLACLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>MIXCLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>MIXMIX=MIXCLA;</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>    out=tclust(Y,j,0.1,restrfactor,'mixt',2);</ItemCell>
            <ItemCell>    MIXMIX(j,2)=out.MIXMIX;</ItemCell>
            <ItemCell>    MIXCLA(j,2)=out.MIXCLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,1)</ItemCell>
            <ItemCell>plot(CLACLA(:,1),CLACLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('CLACLA')</ItemCell>
            <ItemCell>subplot(1,3,2)</ItemCell>
            <ItemCell>plot(MIXMIX(:,1),MIXMIX(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXMIX')</ItemCell>
            <ItemCell>subplot(1,3,3)</ItemCell>
            <ItemCell>plot(MIXCLA(:,1),MIXCLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXCLA (ICL)')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to Swiss banknotes imposing determinant restriciton.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>load('swiss_banknotes');</ItemCell>
            <ItemCell>Y=swiss_banknotes.data;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.01,20,'restrtype','deter','refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the Geyser data imposing determinant restriciton.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>out=tclust(Y,4,0.1,10,'restrtype','deter','refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>