<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->LTSts</Title>
   <Purpose><!--This is the second line of the .m file-->LTSts extends LTS estimator to time series
</Purpose>
   <Description><!--Description section-->It is possible to introduce a trend (up to third order), seasonality (constant or of varying amplitude and with a different number of harmonics) and a level shift (in this last case it is possible to specify the window in which level shift has to be searched for).
</Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>y</Name>
         <ShortDesc>Time series to analyze.</ShortDesc>
         <TypeInd>Vector.</TypeInd>
         <LongDesc>A row or a column vector with T elements, which contains the time series.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>model</Name>
         <ShortDesc>model type.</ShortDesc>
         <TypeInd>Structure.</TypeInd>
         <LongDesc>A structure which specifies the model which will be used. The model structure contains the following fields:
model.s = scalar (length of seasonal period). For monthly data s=12 (default), for quartely data s=4, ...
model.trend = scalar (order of the trend component).
trend = 1 implies linear trend with interecept (default), trend = 2 implies quadratic trend ...
model.seasonal = scalar (integer specifying number of frequencies, i.e. harmonics, in the seasonal component. Possible values for seasonal are $1, 2, ..., [s/2]$, where $[s/2]=floor(s/2)$.
For example:
if seasonal =1 (default) we have:
$\beta_1 \cos( 2 \pi t/s) + \beta_2 sin ( 2 \pi t/s)$;
if seasonal =2 we have:
$\beta_1 \cos( 2 \pi t/s) + \beta_2 \sin ( 2 \pi t/s) + \beta_3 \cos(4 \pi t/s) + \beta_4 \sin (4 \pi t/s)$.
Note that when $s$ is even the sine term disappears for $j=s/2$ and so the maximum number of trigonometric parameters is $s-1$.
If seasonal is a number greater than 100 then it is possible to specify how the seasonal component grows over time.
For example, seasonal =101 implies a seasonal component which just uses one frequency which grows linearly over time as follows:
$(1+\beta_3 t)\times ( \beta_1 cos( 2 \pi t/s) + \beta_2 \sin ( 2 \pi t/s))$.
For example, seasonal =201 implies a seasonal component which just uses one frequency which grows in a quadratic way over time as follows:
$(1+\beta_3 t + \beta_4 t^2)\times( \beta_1 \cos( 2 \pi t/s) + \beta_2 \sin ( 2 \pi t/s))$.
model.X = matrix of size T-by-nexpl containing the values of nexpl extra covariates which are likely to affect y.
model.lshift = scalar greater or equal than 0 which specifies whether it is necessary to include a level shift component. lshift = 0 (default) implies no level shift component. If lshift is an interger greater then 0 then it is possible to specify the moment to start considering level shifts. For example if lshift =13 then the following additional parameters are estimated $\beta_{LS1}* I(t \geq beta_{LS2})$ where $\beta_{LS1}$ is a real number and $\beta_{LS2}$ is an integer which assumes values 14, 14, ..., T-13.
In general, the level shift which are considered are referred to times (lshift+1):(T-lshift).
Remark: the default model is for monthly data with a linear trend (2 parameters) + seasonal component with just one harmonic (2 parameters), no additional explanatory variables and no level shift that is model=struct;
model.s=12;
model.trend=1;
model.seasonal=1;
model.X='';
model.lshift=0;</LongDesc>
         <Example>'model', model</Example>
         <DataType>struct</DataType>
         <Struct>
            <ItemCell>
               <Value>s</Value>
               <Description>scalar (length of seasonal period). For monthly&#xD;
                         data s=12 (default), for quartely data s=4, ...</Description>
            </ItemCell>
            <ItemCell>
               <Value>trend</Value>
               <Description>scalar (order of the trend component).&#xD;
                       trend = 1 implies linear trend with interecept (default),&#xD;
                       trend = 2 implies quadratic trend ...</Description>
            </ItemCell>
            <ItemCell>
               <Value>seasonal</Value>
               <Description>scalar (integer specifying number of&#xD;
                        frequencies, i.e. harmonics, in the seasonal&#xD;
                        component. Possible values for seasonal are&#xD;
                        $1, 2, ..., [s/2]$, where $[s/2]=floor(s/2)$.&#xD;
                        For example:&#xD;
                        if seasonal =1 (default) we have:&#xD;
                        $\beta_1 \cos( 2 \pi t/s) + \beta_2 sin ( 2 \pi t/s)$;&#xD;
                        if seasonal =2 we have:&#xD;
                        $\beta_1 \cos( 2 \pi t/s) + \beta_2 \sin ( 2 \pi t/s)&#xD;
                        + \beta_3 \cos(4 \pi t/s) + \beta_4 \sin (4 \pi t/s)$.&#xD;
                        Note that when $s$ is even the sine term disappears&#xD;
                        for $j=s/2$ and so the maximum number of&#xD;
                        trigonometric parameters is $s-1$.&#xD;
                        If seasonal is a number greater than 100 then it&#xD;
                        is possible to specify how the seasonal component&#xD;
                        grows over time.&#xD;
                        For example, seasonal =101 implies a seasonal&#xD;
                        component which just uses one frequency&#xD;
                        which grows linearly over time as follows:&#xD;
                        $(1+\beta_3 t)\times ( \beta_1 cos( 2 \pi t/s) +&#xD;
                        \beta_2 \sin ( 2 \pi t/s))$.&#xD;
                        For example, seasonal =201 implies a seasonal&#xD;
                        component which just uses one frequency&#xD;
                        which grows in a quadratic way over time as&#xD;
                        follows:&#xD;
                        $(1+\beta_3 t + \beta_4  t^2)\times( \beta_1 \cos(&#xD;
                        2 \pi t/s) + \beta_2 \sin ( 2 \pi t/s))$.</Description>
            </ItemCell>
            <ItemCell>
               <Value>X</Value>
               <Description>matrix of size T-by-nexpl containing the&#xD;
                         values of nexpl extra covariates which are likely&#xD;
                         to affect y.</Description>
            </ItemCell>
            <ItemCell>
               <Value>lshift</Value>
               <Description>scalar greater or equal than 0 which&#xD;
                         specifies whether it is necessary to include a&#xD;
                         level shift component. lshift = 0 (default)&#xD;
                         implies no level shift component. If lshift is an&#xD;
                         interger greater then 0 then it is possible to&#xD;
                         specify the moment to start considering level&#xD;
                         shifts. For example if lshift =13 then the&#xD;
                         following additional parameters are estimated&#xD;
                          $\beta_{LS1}* I(t \geq beta_{LS2})$ where $\beta_{LS1}$&#xD;
                          is a real number and $\beta_{LS2}$ is an integer&#xD;
                          which assumes values 14, 14, ..., T-13.&#xD;
                         In general, the level shift which are considered&#xD;
                         are referred to times (lshift+1):(T-lshift).&#xD;
                                Remark: the default model is for monthly data with a linear&#xD;
               trend (2 parameters) + seasonal component with just one&#xD;
               harmonic (2 parameters), no additional explanatory&#xD;
               variables and no level shift that is&#xD;
                               model=struct;&#xD;
                               model.s=12;&#xD;
                               model.trend=1;&#xD;
                               model.seasonal=1;&#xD;
                               model.X='';&#xD;
                               model.lshift=0;</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>intercept</Name>
         <ShortDesc>Indicator for constant term.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If 1, a model with constant term will be fitted (default), else no constant term will be included.</LongDesc>
         <Example>'intercept',1</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>h</Name>
         <ShortDesc>The number of observations that determined the least trimmed squares estimator.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>h is an integer greater than p (number of columns of matrix X including the intercept but smaller then n. If the purpose is outlier detection than h does not have to be smaller than [0.5*(T+p+1)]. The default value of h is [0.75*T]. Note that if h is supplied input argument bdp is ignored.</LongDesc>
         <Example>'h',round(n*0,75)</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>bdp</Name>
         <ShortDesc>breakdown point.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>It measures the fraction of outliers the algorithm should resist. In this case any value greater than 0 but smaller or equal than 0.5 will do fine. Please specify h or bdp, but not both.</LongDesc>
         <Example>'bdp',0.4</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>lts</Name>
         <ShortDesc>structure which controls a set of options of the maximization procedure.</ShortDesc>
         <TypeInd>Structure.</TypeInd>
         <LongDesc>Structure with the following fields:
lts.refsteps = scalar defining number of concentration steps (default = 2). refsteps = 0 means "raw-subsampling" without iterations.
lts.reftol = scalar. Default value of tolerance for the refining steps The default value is 1e-6;
lts.bestr = scalar defining number of "best betas" to remember from the subsamples. These will be later iterated until convergence.
The default is 20 (10 of them are the best from previous iteration in case a level shift is present).
lts.refstepsbestr = scalar defining maximum number of refining steps for each best subset (default=50).
lts.reftolbestr = scalar. Default value of tolerance for the refining steps for each of the best subsets The default value is 1e-8.
Remark: if lts is an empty value all default values of structure lts will be used.</LongDesc>
         <Example>'lts',lts</Example>
         <DataType>struct</DataType>
         <Struct>
            <ItemCell>
               <Value>refsteps</Value>
               <Description>scalar defining number of concentration&#xD;
                               steps (default = 2). refsteps = 0 means&#xD;
                               "raw-subsampling" without iterations.</Description>
            </ItemCell>
            <ItemCell>
               <Value>reftol</Value>
               <Description>scalar. Default value of tolerance for&#xD;
                               the refining steps&#xD;
                               The default value is 1e-6;</Description>
            </ItemCell>
            <ItemCell>
               <Value>bestr</Value>
               <Description>scalar defining number of "best betas" to&#xD;
                               remember from the subsamples. These will be&#xD;
                               later iterated until convergence.&#xD;
                               The default is 20 (10 of them are the best&#xD;
                               from previous iteration in case a level&#xD;
                               shift is present).</Description>
            </ItemCell>
            <ItemCell>
               <Value>refstepsbestr</Value>
               <Description>scalar defining maximum number of refining&#xD;
                               steps for each best subset (default=50).</Description>
            </ItemCell>
            <ItemCell>
               <Value>reftolbestr</Value>
               <Description>scalar. Default value of tolerance for&#xD;
                               the refining steps for each of the best&#xD;
                               subsets The default value is 1e-8.&#xD;
                              Remark: if lts is an empty value all default values of&#xD;
              structure lts will be used.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>nsamp</Name>
         <ShortDesc>number of subsamples to extract.</ShortDesc>
         <TypeInd>Scalar or vector of length 2.</TypeInd>
         <LongDesc>Vector of length 1 or 2 which controls the number of subsamples which will be extracted to find the robust estimator. If lshift&amp;gt;0 then nsamp(1) controls the number of subsets which have to be extracted to find the solution for t=lshift. nsamp(2) controls the number of subsets which have to be extracted to find the solution for t=lshift+1, lshift+2, ..., T-lshift.
Note that nsamp(2) is generally smaller than nsamp(1) because in order to compute the best solution for t=lshift+1, lshift+2, ..., T-lshift, we use the lts.bestr/2 best solutions from previous t (after shifting by one the position of the level shift in the estimator of beta). If lshift is &amp;gt;0 the default value of nsamp is (500 250). If lshift is &amp;gt;0 and nsamp is supplied as a scalar the default is to extract [nsamp/2] subsamples for t=lshift+1, lshift+2, ... Therefore, for example, in order to extract 600 subsamples for t=lshift and 300 subsamples for t= lshift+1 ... you can use nsamp =600 or nsamp=[600 300].
The default value of nsamp is 1000;
Remark: if nsamp=0 all subsets will be extracted.
They will be (n choose p).</LongDesc>
         <Example>'nsamp',500</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftolALS</Name>
         <ShortDesc>Tolerance inside ALS.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Tolerance value of tolerance for the refining steps inside ALS routine. The default value is 1e-03.</LongDesc>
         <Example>'reftolALS',1e-05</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refstepsALS</Name>
         <ShortDesc>Maximum iterations inside ALS.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Maximum number of iterations inside ALS routine. Default value of tolerance for the refining steps inside ALS routine. The default value is 50.</LongDesc>
         <Example>'refstepsALS',20</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>conflev</Name>
         <ShortDesc>Confidence level.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar between 0 and 1 containing Confidence level which is used to declare units as outliers. Usually conflev=0.95, 0.975 0.99 (individual alpha) or 1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). Default value is 0.975.</LongDesc>
         <Example>'conflev',0.99</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plots on the screen.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If plots = 1, a two panel plot will be shown on the screen.
The upper panel contains the orginal time series with fitted values. The bottom panel will contain the plot ofrobust residuals against index number. The confidence level which is used to draw the horizontal lines associated with the bands for the residuals is specified in input option conflev. If conflev is missing a nominal 0.975 confidence interval will be used. If plots =2 the following additional plots will be shown on the screen.
1) Boxplot of the distribution of the lts.bestr values of the target function for each tentative level shift position;
2) A two panel plot which shows the values of the local sum of squares varying the position of the level shift around the first tentative position keeping all the other parameters fixed. Top panel refers to Huberized residuals sum of squares and bottom panel refers to residual sum of squares.
3) A plot which shows the indexes of the best nbestindexes solutions for each tentative level shift position.
4) A plot which shows the relative frequency of inclusion of each unit in the best h-subset after lts.refsteps refining steps.
5) A plot which shows the relative frequency of inclusion of each unit inside the best nbestindexes subsets which are brought to full convergence.
The default value of plot is 0 i.e. no plot is shown on the screen.</LongDesc>
         <Example>'plots',1</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>SmallSampleCor</Name>
         <ShortDesc>Small sample correction factor to control empirical size of the test.</ShortDesc>
         <TypeInd>Scalar equal to 1 or 2 (default) or 3 or 4.</TypeInd>
         <LongDesc>- If SmallSampleCor=1 in the reweighting step the nominal threshold based on $\chi^2_{0.99}$ is multiplied by the small sample correction factor which guarrantees that the empirical size of the test is equal to the nominal size.
Given that the correction factors were obtained through simulation for a linear model, the number of explanatory which is used to compute the correction factor refers to all explanatory variables except the non linear components in the seasonal part of the model. For example, in a model with linear trend 4 seasonal harmonics + level shift and second order trend in the seasonal component the number of explanatory variables used is 11 = total number of variables -2 = 2 (linear trend) + 8 (4 seasonal harmonics) +1 (level shift).
- If SmallSampleCor =2 Gervini and Yohai procedure is called with 'iterating' false and 'alpha' 0.99 is invoked, that is:
weights=GYfilt(stdres,'iterating',false,'alpha',0.99);
- If SmallSampleCor =3 Gervini and Yohai procedure called with 'iterating' true and 'alpha' 0.99 is invoked, that is:
weights=GYfilt(stdres,'iterating',true,'alpha',0.99);
- If SmallSampleCor =4 $\chi^2_{0.99}$ threshold is used that is:
weights = abs(stdres)&amp;lt;=sqrt(chi2inv(0.99,1));</LongDesc>
         <Example>'SmallSampleCor',3</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>msg</Name>
         <ShortDesc>Messages on the screen.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which controls whether to display or not messages on the screen If msg==1 (default) messages are displayed on the screen about estimated time to compute the estimator and the warnings about 'MATLAB:rankDeficientMatrix', 'MATLAB:singularMatrix' and 'MATLAB:nearlySingularMatrix' are set to off else no message is displayed on the screen</LongDesc>
         <Example>'msg',1</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on matrix y and matrix X. Notice that y and X are left unchanged. In other words the additioanl column of ones for the intercept is not added. As default nocheck=0. The controls on h, bdp and nsamp still remain.</LongDesc>
         <Example>'nocheck',1</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>lshiftlocref</Name>
         <ShortDesc>Parameters for local shift refinement.</ShortDesc>
         <TypeInd>Structure.</TypeInd>
         <LongDesc>This option is used just if model.lshift is greater then 0.
In order to precisely identify level shift position it is necessary to consider a local sum of squares varying the position of the level shift around the first tentative position keeping all the other parameters fixed. This structure contains the following fields:
lshiftlocref.wlength = scalar greater than 0 which identifies the length of the window. The default value is 15, that is the tentative level shift position varies from tl-15, tl-15, ..., tl+14, tl+15, where tl is the best preliminary tentative level shift position.
lshiftlocref.typeres = scalar which identifies the type of residuals to consider. If typerres =1, the local residuals sum of squares is based on huberized (scaled) residuals (this is the default choice) else raw residuals are used.
lshiftlocref.huberc= tuning constant for Huber estimator just in case lshiftlocref.typeres=1. The default value is 2.</LongDesc>
         <Example>'lshiftlocref',lshiftlocref.typeres=2</Example>
         <DataType>struct</DataType>
         <Struct>
            <ItemCell>
               <Value>wlength</Value>
               <Description>scalar greater than 0 which&#xD;
                   identifies the length of the window. The default value&#xD;
                   is 15, that is the tentative level shift position&#xD;
                   varies from tl-15, tl-15, ..., tl+14, tl+15, where tl is&#xD;
                   the best preliminary tentative level shift position.</Description>
            </ItemCell>
            <ItemCell>
               <Value>typeres</Value>
               <Description>scalar which identifies the type of&#xD;
                   residuals to consider. If typerres =1, the local&#xD;
                   residuals sum of squares is based on huberized (scaled)&#xD;
                   residuals (this is the default&#xD;
                   choice) else raw residuals are used.</Description>
            </ItemCell>
            <ItemCell>
               <Value>huberc</Value>
               <Description>tuning constant for Huber estimator just&#xD;
                   in case lshiftlocref.typeres=1. The default value is 2.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>nbestindexes</Name>
         <ShortDesc>position of the best solutions.</ShortDesc>
         <TypeInd>Positive integer.</TypeInd>
         <LongDesc>For each tentative level shift solution, it is interesenting to understand whether best solutions of target function come from subsets associated with current level shift solution or from best solutions from previous tentative level shift position. The indexes from 1 to lts.bestr/2 are associated with subsets just extracted. The indexes from lts.bestr/2+1 to lts.bestr are associated with best solutions from previous tentative level shift. More precisely:
index lts.bestr/2+1 is associated with best solution from previous tentative level shift;
index lts.bestr/2+2 is associated with second best solution from previous tentative level shift;
...
nbestindexes is an integer which specifies how many indexes we want to store. The default value of nbestindexes is 3.</LongDesc>
         <Example>'nbestindexes',5</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>dispresults</Name>
         <ShortDesc>Display results of final fit.</ShortDesc>
         <TypeInd>Boolean.</TypeInd>
         <LongDesc>If dispresults is true, labels of coefficients, estimated coefficients, standard errors, tstat and p-values are shown on the screen in a fully formatted way. The default value of dispresults is false.</LongDesc>
         <Example>'dispresults',true</Example>
         <DataType>logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>yxsave</Name>
         <ShortDesc>store X and y.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar that is set to 1 to request that the response vector y and data matrix X are saved into the output structure out. Default is 0, i.e. no saving is done.</LongDesc>
         <Example>'yxsave',1</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Structure>
            <ItemCell>
               <Value>B</Value>
               <Description>Matrix containing estimated beta coefficients, (including the intercept when options.intercept=1) standard errors, t-stat and p-values The content of matrix B is as follows:
1st col = beta coefficients The order of the beta coefficients is as follows:
1) trend elements (if present). If the trend is of order two there are r+1 coefficients if the intercept is present otherwise there are just r components;
2) linear part of seasonal component 2, 4, 6, ..., s-2, s-1 coefficients (if present);
3) coefficients associated with the matrix of explanatory variables which have a potential effect on the time series under study (X);
4) non linear part of seasonal component, that is varying amplitude. If varying amplitude is of order k there are k coefficients (if present);
5) level shift component (if present). In this case there are two coefficients, the second (which is also the last element of vector beta) is an integer which specifies the time in which level shift takes place and the first (which is also the penultime element of vector beta) is a real number which identifies the magnitude of the upward (downward) level shift;
2nd col = standard errors;
3rd col = t-statistics;
4th col = p values.</Description>
            </ItemCell>
            <ItemCell>
               <Value>h</Value>
               <Description>The number of observations that have determined the initial LTS estimator, i.e. the value of h.</Description>
            </ItemCell>
            <ItemCell>
               <Value>bs</Value>
               <Description>Vector containing the units forming best initial elemental subset (that is elemental subset which produced the smallest value of the target function).</Description>
            </ItemCell>
            <ItemCell>
               <Value>Hsubset</Value>
               <Description>matrix of size T-by-(T-2*lshift) containing units forming best H subset for each tentative level shift which is considered.
Units belonging to subset are given with their row number, units not belonging to subset have missing values ( Remark: T-2*lshift = length((lshift+1):(T-lshift)) ) This output is present just if input option model.lshift&amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>posLS</Value>
               <Description>scalar associated with best tentative level shift position.
This output is present just if input option model.lshift&amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>numscale2</Value>
               <Description>matrix of size lts.bestr-by-(T-2*lshift) containing (in the columns the values of the lts.bestr smallest values of the target function. Target function = truncated residuals sum of squares.</Description>
            </ItemCell>
            <ItemCell>
               <Value>BestIndexes</Value>
               <Description>matrix of size nbestindexes-by-(T-2*lshift) containing in each column the indexes associated with the best nbestindexes solutions.
The indexes from lts.bestr/2+1 to lts.bestr are associated with best solutions from previous tentative level shift.
More precisely:
index lts.bestr/2+1 is associated with best solution from previous tentative level shift;
index lts.bestr/2+2 is associated with best solution from previous tentative level shift.
This output is present just if input option model.lshift&amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Likloc</Value>
               <Description>matrix of size (2*lshiftlocref.wlength+1)-by-3 containing local sum of squares of residuals in order to decide best position of level shift:
1st col = position of level shift;
2nd col = local sum of squares of huberized residuals;
3rd col = local sum of squares of raw residuals.
This output is present just if input option model.lshift&amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>RES</Value>
               <Description>Matrix of size T-by-(T-lshift) containing scaled residuals for all the T units of the original time series monitored in steps lshift+1, lshift+2, ..., T-lshift, where lshift+1 is the first tentative level shift position, lshift +2 is the second level shift position, and so on. This output is present just if input option model.lshift&amp;gt;0.</Description>
            </ItemCell>
            <ItemCell>
               <Value>yhat</Value>
               <Description>vector of fitted values after final (NLS=non linear least squares) step.
$ (\hat \eta_1, \hat \eta_2, \ldots, \hat \eta_T)'$</Description>
            </ItemCell>
            <ItemCell>
               <Value>residuals</Value>
               <Description>Vector T-by-1 containing the scaled residuals from after final NLS step.</Description>
            </ItemCell>
            <ItemCell>
               <Value>weights</Value>
               <Description>Vector containing weights after adaptive reweighting. The elements of this vector are 0 or 1. These weights identify the observations which are used to compute the final NLS estimate.</Description>
            </ItemCell>
            <ItemCell>
               <Value>scale</Value>
               <Description>Final scale estimate of the residuals using final weights.
\[
\hat \sigma = cor \times \sum_{i \in S_m} [y_i- \eta(x_i,\hat \beta)]^2/(m-p)
\]
where $S_m$ is a set of cardinality $m$ which contains the units not declared as outliers, $p$ is the total number of estimated parameters and cor is a correction factor to make the estimator consistent.</Description>
            </ItemCell>
            <ItemCell>
               <Value>conflev</Value>
               <Description>confidence level which is used to declare outliers.
Remark: scalar out.conflev will be used to draw the horizontal lines (confidence bands) in the plots</Description>
            </ItemCell>
            <ItemCell>
               <Value>outliers</Value>
               <Description>vector containing the list of the units declared as outliers using confidence level specified in input scalar conflev.</Description>
            </ItemCell>
            <ItemCell>
               <Value>singsub</Value>
               <Description>Number of subsets wihtout full rank. Notice that if this number is greater than 0.1*(number of subsamples) a warning is produced on the screen</Description>
            </ItemCell>
            <ItemCell>
               <Value>invXX</Value>
               <Description>$cov(\beta)/\hat \sigma^2$. p-by-p, square matrix.
If the model is linear out.invXX is equal to $(X'X)^{-1}$, else out.invXX is equal to $(A'A)^{-1}$ where $A$ is the matrix of partial derivatives. More precisely:
\[
a_{i,j}=\frac{\partial \eta_i(\hat \beta)}{\partial \hat \beta_j}
\]
where \begin{eqnarray} y_i &amp; = &amp; \eta(x_i,\beta)+ \epsilon_i \\
&amp; = &amp; \eta_i +\epsilon_i \\
&amp; = &amp; \eta(x_i,\hat \beta)+ e_i \\
&amp; = &amp; \hat \eta_i + e_i \end{eqnarray}</Description>
            </ItemCell>
            <ItemCell>
               <Value>y</Value>
               <Description>response vector y.</Description>
            </ItemCell>
            <ItemCell>
               <Value>X</Value>
               <Description>data matrix X containing trend+seasonal+expl+lshift.
The field is present only if option yxsave is set to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>class</Value>
               <Description>'LTSts'.</Description>
            </ItemCell>
         </Structure>
      </Item>
      <Item>
         <Name>varargout</Name>
         <ShortDesc>C : cell</ShortDesc>
         <TypeInd>Indices of the subsamples extracted for computing the estimate (the so called elemental sets) for each tentative level shift position.</TypeInd>
         <LongDesc>C{1} is associated with the subsamples for first tentative level shift position;
C{2} is associated with the subsamples for second tentative level shift position;
...
C{end} is associated with the subsamples for last tentative level shift position;</LongDesc>
         <Structure> </Structure>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION--></MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Rousseeuw, P.J., Perrotta D., Riani M., Hubert M. (2017), Robust Monitoring of Many Time Series with Application to Fraud Detection, forthcoming in Econometris and Statistics. [Referred below as RPRH]</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>LXS</Item>
      <Item>wedgeplot</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>Simulated data with linear trend and level shift.</Title>
         <Desc>
            <ItemCell>No seasonal component.</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>n=45;</ItemCell>
            <ItemCell>a=1;</ItemCell>
            <ItemCell>b=0.8;</ItemCell>
            <ItemCell>sig=1;</ItemCell>
            <ItemCell>seq=(1:n)';</ItemCell>
            <ItemCell>y=a+b*seq+sig*randn(n,1);</ItemCell>
            <ItemCell>y(round(n/2):end)=y(round(n/2):end)+10;</ItemCell>
            <ItemCell>% model with a quadratic trend, non seasonal and level shift</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=2;</ItemCell>
            <ItemCell>model.seasonal=0;</ItemCell>
            <ItemCell>% Potential level shift position is investigated in positions:</ItemCell>
            <ItemCell>% t=10, t=11, ..., t=T-10.</ItemCell>
            <ItemCell>model.lshift=10;</ItemCell>
            <ItemCell>out=LTSts(y,'model',model,'plots',1);</ItemCell>
            <ItemCell/>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Airline data: linear trend + just one harmonic for seasonal component.</Title>
         <Desc>
            <ItemCell>Load airline data 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 y = [112 115 145 171 196 204 242 284 315 340 360 417 Jan 118 126 150 180 196 188 233 277 301 318 342 391 Feb 132 141 178 193 236 235 267 317 356 362 406 419 Mar 129 135 163 181 235 227 269 313 348 348 396 461 Apr 121 125 172 183 229 234 270 318 355 363 420 472 May 135 149 178 218 243 264 315 374 422 435 472 535 Jun 148 170 199 230 264 302 364 413 465 491 548 622 Jul 148 170 199 242 272 293 347 405 467 505 559 606 Aug 136 158 184 209 237 259 312 355 404 404 463 508 Sep 119 133 162 191 211 229 274 306 347 359 407 461 Oct 104 114 146 172 180 203 237 271 305 310 362 390 Nov 118 140 166 194 201 229 278 306 336 337 405 432 ]; Dec Source:</ItemCell>
            <ItemCell>http://datamarket.com/data/list/?q=provider:tsdl</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>y=(y(:));</ItemCell>
            <ItemCell>yr = repmat((1949:1960),12,1);</ItemCell>
            <ItemCell>mo = repmat((1:12)',1,12);</ItemCell>
            <ItemCell>time = datestr(datenum(yr(:),mo(:),1));</ItemCell>
            <ItemCell>ts = timeseries(y(:),time,'name','AirlinePassengers');</ItemCell>
            <ItemCell>ts.TimeInfo.Format = 'dd-mmm-yyyy';</ItemCell>
            <ItemCell>tscol = tscollection(ts);</ItemCell>
            <ItemCell>% plot airline data</ItemCell>
            <ItemCell>plot(ts)</ItemCell>
            <ItemCell>% linear trend + just one harmonic for seasonal component</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=1;           % just one harmonic</ItemCell>
            <ItemCell>model.lshift=0;             % no level shift</ItemCell>
            <ItemCell>out=LTSts(y,'model',model,'dispresults',true);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(y);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Model with linear trend and six harmonics for seasonal component.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=6;           % six harmonics</ItemCell>
            <ItemCell>model.lshift=0;             % no level shift</ItemCell>
            <ItemCell>out=LTSts(y,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(y);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>Model with linear trend, two harmonics for seasonal component and varying amplitude using a linear trend.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=102;         % two harmonics with time varying seasonality</ItemCell>
            <ItemCell>model.lshift=0;             % no level shift</ItemCell>
            <ItemCell>out=LTSts(y,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(y);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Model with linear trend, six harmonics for seasonal component and varying amplitude using a linear trend).</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=106;         % six harmonics with linear time varying seasonality</ItemCell>
            <ItemCell>model.lshift=0;             % no level shift</ItemCell>
            <ItemCell>% out=fitTSLS(y,'model',model);</ItemCell>
            <ItemCell>out=LTSts(y,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(y);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Contaminated time series with upward level shift.</Title>
         <Desc>
            <ItemCell>Model with linear trend, six harmonics for seasonal component and varying amplitude using a linear trend).</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>yLS=y;</ItemCell>
            <ItemCell>yLS(55:end)=yLS(55:end)+130;</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=1;</ItemCell>
            <ItemCell>model.lshift=13;            % impose level shift</ItemCell>
            <ItemCell>out=LTSts(yLS,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(yLS);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Contaminated time series with downward level shift.</Title>
         <Desc>
            <ItemCell>Model with linear trend, six harmonics for seasonal component and varying amplitude using a linear trend).</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>yLS=y;</ItemCell>
            <ItemCell>yLS(35:end)=yLS(35:end)-300;</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=106;</ItemCell>
            <ItemCell>model.lshift=13;</ItemCell>
            <ItemCell>out=LTSts(yLS,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(yLS);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Model with an explanatory variable using logged series.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>y1=log(y);</ItemCell>
            <ItemCell>% Model with linear trend, six harmonics for seasonal component and</ItemCell>
            <ItemCell>% varying amplitude using a linear trend).</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=1;              % linear trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=106;</ItemCell>
            <ItemCell>model.lshift=0;</ItemCell>
            <ItemCell>model.X=randn(length(y),1);</ItemCell>
            <ItemCell>out=LTSts(y1,'model',model);</ItemCell>
            <ItemCell>close all</ItemCell>
            <ItemCell>% Plot real and fitted values</ItemCell>
            <ItemCell>plot(y1);</ItemCell>
            <ItemCell>hold('on')</ItemCell>
            <ItemCell>plot(out.yhat,'red')</ItemCell>
            <ItemCell>legend('real values','fitted values','Location','SouthEast')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Example 1 used in the paper RPRH.</Title>
         <Desc>
            <ItemCell>Load airline data 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>y = [112  115  145  171  196  204  242  284  315  340  360  417    % Jan</ItemCell>
            <ItemCell>     118  126  150  180  196  188  233  277  301  318  342  391    % Feb</ItemCell>
            <ItemCell>     132  141  178  193  236  235  267  317  356  362  406  419    % Mar</ItemCell>
            <ItemCell>     129  135  163  181  235  227  269  313  348  348  396  461    % Apr</ItemCell>
            <ItemCell>     121  125  172  183  229  234  270  318  355  363  420  472    % May</ItemCell>
            <ItemCell>     135  149  178  218  243  264  315  374  422  435  472  535    % Jun</ItemCell>
            <ItemCell>     148  170  199  230  264  302  364  413  465  491  548  622    % Jul</ItemCell>
            <ItemCell>     148  170  199  242  272  293  347  405  467  505  559  606    % Aug</ItemCell>
            <ItemCell>     136  158  184  209  237  259  312  355  404  404  463  508    % Sep</ItemCell>
            <ItemCell>     119  133  162  191  211  229  274  306  347  359  407  461    % Oct</ItemCell>
            <ItemCell>     104  114  146  172  180  203  237  271  305  310  362  390    % Nov</ItemCell>
            <ItemCell>     118  140  166  194  201  229  278  306  336  337  405  432 ]; % Dec</ItemCell>
            <ItemCell>% Two short level shifts in opposite directions and an isolated outlier.</ItemCell>
            <ItemCell>% Add a level shift contamination plus some outliers.</ItemCell>
            <ItemCell>y1=y(:);</ItemCell>
            <ItemCell>y1(50:55)=y1(50:55)-300;</ItemCell>
            <ItemCell>y1(70:75)=y1(70:75)+300;</ItemCell>
            <ItemCell>y1(90:90)=y1(90:90)+300;</ItemCell>
            <ItemCell>% Create structure specifying model</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=2;              % quadratic trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=204;         % number of harmonics</ItemCell>
            <ItemCell>model.lshift=40;            % position where to start monitoring level shift</ItemCell>
            <ItemCell>model.X='';</ItemCell>
            <ItemCell>% Create structure lts specifying lts options</ItemCell>
            <ItemCell>lshiftlocref=struct;</ItemCell>
            <ItemCell>% Set window length for local refinement.</ItemCell>
            <ItemCell>lshiftlocref.wlength=10;</ItemCell>
            <ItemCell>% Set tuning constant to use insde Huber rho function</ItemCell>
            <ItemCell>lshiftlocref.huberc=1.5;</ItemCell>
            <ItemCell>% Estimate the parameters</ItemCell>
            <ItemCell>[out]=LTSts(y1,'model',model,'nsamp',500,...</ItemCell>
            <ItemCell>   'plots',1,'lshiftlocref',lshiftlocref,'msg',0);</ItemCell>
            <ItemCell>% generate the wedgeplot</ItemCell>
            <ItemCell>% wedgeplot(out,'transpose',true,'extradata',[y1 out.yhat]);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Example 2 used in the paper RPRH.</Title>
         <Desc>
            <ItemCell>A persisting level shift and three isolated outliers, two of which in proximity of the level shift.</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>y1=y(:);</ItemCell>
            <ItemCell>y1(68:end)=y1(68:end)+1300;</ItemCell>
            <ItemCell>y1(67)=y1(67)-600;</ItemCell>
            <ItemCell>y1(45)=y1(45)-800;</ItemCell>
            <ItemCell>y1(68:69)=y1(68:69)+800;</ItemCell>
            <ItemCell>% Create structure specifying model</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=2;              % quadratic trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=204;         % number of harmonics</ItemCell>
            <ItemCell>model.lshift=40;            % position where to start monitoring level shift</ItemCell>
            <ItemCell>model.X='';</ItemCell>
            <ItemCell>% Create structure lts specifying lts options</ItemCell>
            <ItemCell>lshiftlocref=struct;</ItemCell>
            <ItemCell>% Set window length for local refinement.</ItemCell>
            <ItemCell>lshiftlocref.wlength=10;</ItemCell>
            <ItemCell>% Set tuning constant to use insde Huber rho function</ItemCell>
            <ItemCell>lshiftlocref.huberc=1.5;</ItemCell>
            <ItemCell>% Estimate the parameters</ItemCell>
            <ItemCell>[out, varargout]=LTSts(y1,'model',model,'nsamp',500,...</ItemCell>
            <ItemCell>   'plots',1,'lshiftlocref',lshiftlocref,'msg',0);</ItemCell>
            <ItemCell>% generate the wedgeplot</ItemCell>
            <ItemCell>% wedgeplot(out,'transpose',true,'extradata',[y1 out.yhat]);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Example 3 used in the paper RPRH.</Title>
         <Desc>
            <ItemCell>A persisting level shift preceded and followed in the proximity by other two short level shifts, and an isolated outlier.</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>y1=y(:);</ItemCell>
            <ItemCell>y1(50:55)=y1(50:55)-300;</ItemCell>
            <ItemCell>y1(68:end)=y1(68:end)-700;</ItemCell>
            <ItemCell>y1(70:75)=y1(70:75)+300;</ItemCell>
            <ItemCell>y1(90:90)=y1(90:90)+300;</ItemCell>
            <ItemCell>% Create structure specifying model</ItemCell>
            <ItemCell>model=struct;</ItemCell>
            <ItemCell>model.trend=2;              % quadratic trend</ItemCell>
            <ItemCell>model.s=12;                 % monthly time series</ItemCell>
            <ItemCell>model.seasonal=204;         % number of harmonics</ItemCell>
            <ItemCell>model.lshift=40;            % position where to start monitoring level shift</ItemCell>
            <ItemCell>model.X='';</ItemCell>
            <ItemCell>% Create structure lts specifying lts options</ItemCell>
            <ItemCell>lshiftlocref=struct;</ItemCell>
            <ItemCell>% Set window length for local refinement.</ItemCell>
            <ItemCell>lshiftlocref.wlength=10;</ItemCell>
            <ItemCell>% Set tuning constant to use insde Huber rho function</ItemCell>
            <ItemCell>lshiftlocref.huberc=1.5;</ItemCell>
            <ItemCell>% Estimate the parameters</ItemCell>
            <ItemCell>[out, varargout]=LTSts(y1,'model',model,'nsamp',500,...</ItemCell>
            <ItemCell>   'plots',2,'lshiftlocref',lshiftlocref,'msg',0);</ItemCell>
            <ItemCell>% generate the wedgeplot</ItemCell>
            <ItemCell>% wedgeplot(out,'transpose',true,'extradata',[y1 out.yhat]);</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
   </ExtraEx>
</HelpXML>