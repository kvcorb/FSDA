<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->tclust</Title>
   <Purpose><!--This is the second line of the .m file-->tclust computes trimmed clustering with restricitons on the eigenvalues
</Purpose>
   <Description><!--Description section-->tclust partitions the points in the n-by-v data matrix Y into k clusters. This partition minimizes the trimmed sum, over all clusters, of the within-cluster sums of point-to-cluster-centroid distances. Rows of Y correspond to points, columns correspond to variables. tclust returns inside structure out an n-by-1 vector idx containing the cluster indices of each point. By default, tclust uses (squared), possibly constrained, Mahalanobis distances.
</Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>Y</Name>
         <ShortDesc>Data matrix containing n observations on v variables.</ShortDesc>
         <TypeInd>Rows of Y represent observations, and columns represent variables.</TypeInd>
         <LongDesc>Missing values (NaN's) and infinite values (Inf's) are allowed, since observations (rows) with missing or infinite values will automatically be excluded from the computations.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>k</Name>
         <ShortDesc>Number of groups.</ShortDesc>
         <TypeInd>Scalar which specifies the number of groups.</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>alpha</Name>
         <ShortDesc>global trimming level.</ShortDesc>
         <TypeInd>alpha is a scalar between 0 and 0.5 or an integer specifying the number of observations which have to be trimmed.</TypeInd>
         <LongDesc>If alpha=0 tclust reduces to traditional model based or mixture clustering (mclust): see Matlab function gmdistribution.
More in detail, if 0&amp;lt; alpha &amp;lt;1 clustering is based on h=fix(n*(1-alpha)) observations Else if alpha is an integer greater than 1 clustering is based on h=n-floor(alpha);</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrfactor</Name>
         <ShortDesc>positive scalar which constrains the allowed differences among group scatters.</ShortDesc>
         <TypeInd>Larger values imply larger differences of group scatters.</TypeInd>
         <LongDesc>On the other hand a value of 1 specifies the strongest restriction forcing all eigenvalues/determinants to be equal and so the method looks for similarly scattered (respectively spherical) clusters.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>nsamp</Name>
         <ShortDesc>number of subsamples to extract.</ShortDesc>
         <TypeInd>Scalar or matrix.</TypeInd>
         <LongDesc>If nsamp is a scalar it contains the number of subsamples which will be extracted. If nsamp=0 all subsets will be extracted.
Remark - if the number of all possible subset is &amp;lt;300 the default is to extract all subsets, otherwise just 300 If nsamp is a matrix it contains in the rows the indexes of the subsets which have to be extracted. nsamp in this case can be conveniently generated by function subsets. nsamp can have k columns or k*(v+1) columns. If nsamp has k columns the k initial centroids each iteration i are given by X(nsamp(i,:),:) and the covariance matrices are equal to the identity.
If nsamp has k*(v+1) columns the initial centroids and covariance matrices in iteration i are computed as follows:
X1=X(nsamp(i,:),:);
mean(X1(1:v+1,:)) contains the initial centroid for group 1;
cov(X1(1:v+1,:)) contains the initial cov matrix for group 1;
mean(X1(v+2:2*v+2,:)) contains the initial centroid for group 2;
cov((v+2:2*v+2,:)) contains the initial cov matrix for group 2;
...;
mean(X1((k-1)*v+1:k*(v+1))) contains the initial centroids for group k;
cov(X1((k-1)*v+1:k*(v+1))) contains the initial cov matrix for group k.
REMARK - if nsamp is not a scalar option option below startv1 is ignored. More precisely, if nsamp has k columns startv1=0 elseif nsamp has k*(v+1) columns option startv1 =1.</LongDesc>
         <Example>'nsamp',1000</Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refsteps</Name>
         <ShortDesc>Number of refining iterations.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Number of refining iterations in each subsample Default is 15.
refsteps = 0 means "raw-subsampling" without iterations.</LongDesc>
         <Example>'refsteps',10</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftol</Name>
         <ShortDesc>tolerance for the refining steps.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>The default value is 1e-14;</LongDesc>
         <Example>'reftol',1e-05</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>equalweights</Name>
         <ShortDesc>cluster weights in the concentration and assignment steps.</ShortDesc>
         <TypeInd>Logical.</TypeInd>
         <LongDesc>A logical value specifying whether cluster weights shall be considered in the concentration, assignment steps and computation of the likelihood.
if equalweights = true we are (ideally) assuming equally sized groups by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log f(x_i; m_j , S_j)
\]
else if equalweights = false (default) we allow for different group weights by maximizing:
\[
\sum_{j=1}^k \sum_{ x_i \in group_j } \log \left[ \frac{n_j}{n} f(x_i; m_j , S_j) \right]=
\]
\[
= \sum_{j=1}^k n_j \log n_j/n + \sum_{j=1}^k \sum_{ x_i \in group_j} \log f(x_i; m_j , S_j)
\]
Remark: $\sum_{j=1}^k n_j \log n_j/n$ is the so called entropy term</LongDesc>
         <Example>'equalweights',true</Example>
         <DataType>Logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>mixt</Name>
         <ShortDesc>mixture modelling or crisp assignment.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Option mixt specifies whether mixture modelling or crisp assignment approach to model based clustering must be used.
In the case of mixture modelling parameter mixt also controls which is the criterior to find the untrimmed units in each step of the maximization If mixt &amp;gt;=1 mixture modelling is assumed else crisp assignment.
In mixture modelling the likelihood is given by
\[
\prod_{i=1}^n \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j),
\]
while in crisp assignment the likelihood is given by
\[
\prod_{j=1}^k \prod _{i\in R_j} \phi (y_i; \; \theta_j),
\]
where $R_j$ contains the indexes of the observations which are assigned to group $j$, Remark - if mixt&amp;gt;=1 previous parameter equalweights is automatically set to 1.
Parameter mixt also controls the criterion to select the units to trim if mixt == 2 the h units are those which give the largest contribution to the likelihood that is the h largest values of
\[
\sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j) \qquad i=1, 2, ..., n
\]
elseif mixt==1 the criterion to select the h units is exactly the same as the one which is used in crisp assignment. That is: the n units are allocated to a cluster according to criterion
\[
\max_{j=1, \ldots, k} \hat \pi'_j \phi (y_i; \; \hat \theta_j)
\]
and then these n numbers are ordered and the units associated with the largest h numbers are untrimmed.</LongDesc>
         <Example>'mixt',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen.</ShortDesc>
         <TypeInd>Scalar or matrix or string.</TypeInd>
         <LongDesc>- If plots = 0 (default), plots are not generated.
- If plots = 1, a plot with the classification is shown on the screen. The plot can be:
* for v=1, an histogram of the univariate data.
* for v=2, a bivariate scatterplot.
* for v&amp;gt;2, a scatterplot matrix generated by spmplot.
When v = 2, plots offers the following additional features (for v=1 or v&amp;gt;2 the behaviour is forced that of plots=1):
- plots = 2 superimposes confidence ellipses to the bivariate scatterplot. The size of the ellipse is chi2inv(0.95,2), i.e. the confidence level used by default is 95%.
- 0 &amp;lt; plots &amp;lt; 1 superimposes confidence ellipses with size given by chi2inv(plots,2), i.e. with the confidence level provided by the user in plots.
- plots = 'contour' superimposes to the bivariate scatterplot a contour plot.
- plots = 'contourf' superimposes to the bivariate scatterplot a filled contour plot. The colormap of the filled contour is based on grey levels.
- If plots is three-column matrix of values in the range [0,1], the behaviour is like for 'contourf' but with a personalized colormap where each row of 'plots' is an RGB triplet that defines one color.</LongDesc>
         <Example>'plots',1</Example>
         <DataType>single | double | matrix | string</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>msg</Name>
         <ShortDesc>Level of output to display.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Scalar which controls whether to display or not messages on the screen. If msg==1 (default) messages are displayed on the screen about estimated time to compute the estimator or the number of subsets in which there was no convergence else no message is displayed on the screen</LongDesc>
         <Example>'msg',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on matrix Y.
As default nocheck=0.</LongDesc>
         <Example>'nocheck',10</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>startv1</Name>
         <ShortDesc>how to initialize centroids and cov matrices.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>If startv1 is 1 then initial centroids and covariance matrices are based on (v+1) observations randomly chosen, else each centroid is initialized taking a random row of input data matrix and covariance matrices are initialized with identity matrices.
Remark 1- in order to start with a routine which is in the required parameter space, eigenvalue restrictions are immediately applied. The default value of startv1 is 1.
Remark 2 - option startv1 is used just if nsamp is a scalar (see for more details the help associated with nsamp)</LongDesc>
         <Example>'startv1',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restr</Name>
         <ShortDesc>The type of restriction to be applied on the cluster scatter matrices.</ShortDesc>
         <TypeInd>Valid values are 'eigen' (default), or 'deter'.</TypeInd>
         <LongDesc>eigen implies restriction on the eigenvalues while deter implies restrictions on the determinant.</LongDesc>
         <Example>'restr','deter'</Example>
         <DataType>char</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Ysave</Name>
         <ShortDesc>Save original input matrix.</ShortDesc>
         <TypeInd>Scalar.</TypeInd>
         <LongDesc>Set Ysave to 1 to request that the input matrix Y is saved into the output structure out. Default is 0, id est no saving is done.</LongDesc>
         <Example>'Ysave',1</Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Structure>
            <ItemCell>
               <Value>muopt</Value>
               <Description>k-by-v matrix containing cluster centroid locations. Robust estimate of final centroids of the groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>sigmaopt</Value>
               <Description>v-by-v-by-k array containing estimated constrained covariance for the k groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>idx</Value>
               <Description>n-by-1 vector containing assignment of each unit to each of the k groups. Cluster names are integer numbers from 1 to k. 0 indicates trimmed observations.</Description>
            </ItemCell>
            <ItemCell>
               <Value>siz</Value>
               <Description>matrix of size k-by-3 1st col = sequence from 0 to k 2nd col = number of observations in each cluster 3rd col = percentage of observations in each cluster Remark: 0 denotes unassigned units</Description>
            </ItemCell>
            <ItemCell>
               <Value>post</Value>
               <Description>n-by-k matrix containing posterior probabilities out.post(i,j) contains posterior probabilitiy of unit i from component (cluster) j. For the trimmed units posterior probabilities are 0</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXMIX</Value>
               <Description>BIC which uses parameters estimated using the mixture loglikelihood and the maximized mixture likelihood as goodness of fit measure.
Remark: this output is present just if input option mixt is &amp;gt;0</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXCLA</Value>
               <Description>BIC which uses the classification likelihood based on parameters estimated using the mixture likelihood (In some books this quantity is called ICL) Remark: this output is present just if input option mixt is &amp;gt;0</Description>
            </ItemCell>
            <ItemCell>
               <Value>CLACLA</Value>
               <Description>BIC which uses the classification likelihood based on parameters estimated using the classification likelihood Remark: this output is present just if input option mixt is =0</Description>
            </ItemCell>
            <ItemCell>
               <Value>notconver</Value>
               <Description>scalar. Number of subsets without convergence</Description>
            </ItemCell>
            <ItemCell>
               <Value>bs</Value>
               <Description>k-by-1 vector containing the units forming initial subset associated with muopt.</Description>
            </ItemCell>
            <ItemCell>
               <Value>obj</Value>
               <Description>scalar. Value of the objective function which is minimized (value of the best returned solution).
If input option mixt &amp;gt;1 the likelihood which is maximized is a mixture likelihood as follows
\[
\prod_{i=1}^h \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j).
\]
else the likelihood which is maximized is a classification likelihood of the the form
\[
\prod_{j=1}^k \prod _{i\in R_j} \pi_j' \phi (y_i; \; \theta_j),
\]
where $R_j$ contains the indexes of the observations which are assigned to group $j$ with the constraint that $\# \bigcup_{j=1}^k R_j=h$. In the classification likelihood is input option equalweights=0 then $\pi_j'=1$, $j=1, ..., k$</Description>
            </ItemCell>
            <ItemCell>
               <Value>equalweights</Value>
               <Description>logical. It is true if in the clustering procedure we (ideally) assumed equal cluster weights else it is false if we allowed for different cluster sizes</Description>
            </ItemCell>
            <ItemCell>
               <Value>h</Value>
               <Description>scalar. Number of observations that have determined the centroids (number of untrimmed units).</Description>
            </ItemCell>
            <ItemCell>
               <Value>fullsol</Value>
               <Description>column vector of size nsamp which contains the value of the objective function at the end of the iterative process for each extracted subsample.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Y</Value>
               <Description>original data matrix Y. The field is present if option Ysave is set to 1.</Description>
            </ItemCell>
         </Structure>
      </Item>
      <Item>
         <Name>varargout</Name>
         <ShortDesc>Matrix</ShortDesc>
         <TypeInd>C : Indexes of extracted subsamples.</TypeInd>
         <LongDesc>Matrix of size nsamp-by-(v+1)*k containing (in the rows) the indices of the subsamples extracted for computing the estimate.</LongDesc>
         <Structure> </Structure>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->This iterative algorithm initializes k clusters randomly and performs "concentration steps" in order to improve the current cluster assignment. The number of maximum concentration steps to be performed is given by input parameter refsteps. For approximately obtaining the global optimum, the system is initialized nsamp times and concentration steps are performed until convergence or refsteps is reached. When processing more complex data sets higher values of nsamp and refsteps have to be specified (obviously implying extra computation time). However, if more then 10 per cent of the iterations do not converge, a warning message is issued, indicating that nsamp has to be increased.
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Garcia-Escudero, L.A.; Gordaliza, A.; Matran, C. and Mayo-Iscar, A. (2008), "A General Trimming Approach to Robust Cluster Analysis". Annals of Statistics, Vol.36, 1324-1345. Technical Report available at http://www.eio.uva.es/inves/grupos/representaciones/trTCLUST.pdf</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>tkmeans</Item>
      <Item>estepFS</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data using k=3, alpha=0.1 and restrfactor=10000.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000);</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust of geyser with classification plot.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',1);</ItemCell>
            <ItemCell>% tclust of geyser with classification plot and confidence ellipses.</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots',2);</ItemCell>
            <ItemCell>% tclust of geyser with classification plot and contour plots.</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots','contour');</ItemCell>
            <ItemCell>% tclust of geyser with classification plot and filled contour plots.</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10000,'plots','contourf');</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust of geyser with varargout.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>nsamp=20;</ItemCell>
            <ItemCell>[out,MatrixContSubsets]=tclust(Y,3,0.1,10000,'nsamp',nsamp);</ItemCell>
            <ItemCell>% MatrixContSubsets is a matrix containing in the rows the indexes of</ItemCell>
            <ItemCell>% the nsamp subsets which have been extracted</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data (output comparison).</Title>
         <Desc>
            <ItemCell>We compare the output using three different values of restriction factor.</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>close all</ItemCell>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>restrfactor=10000;</ItemCell>
            <ItemCell>% nsamp = number of subsamples which will be extracted</ItemCell>
            <ItemCell>nsamp=500;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'plots',1);</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor)])</ItemCell>
            <ItemCell>restrfactor=10;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots',1);</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor)])</ItemCell>
            <ItemCell>% trimmed k-means solution restrfactor=1</ItemCell>
            <ItemCell>restrfactor=1;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots',1);</ItemCell>
            <ItemCell>title(['Restriction factor =' num2str(restrfactor) '. Trimmed k-means solution'])</ItemCell>
            <ItemCell>cascade</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the M5data.</Title>
         <Desc>
            <ItemCell>A bivariate data set obtained from three normal bivariate distributions with different scales and proportions 1:2:2. One of the components is very overlapped with another one. A 10 per cent background noise is added uniformly distributed in a rectangle containing the three normal components and not very overlapped with the three mixture components. A precise description of the M5 data set can be found in Garcia-Escudero et al. (2008).</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>Y=load('M5data.txt');</ItemCell>
            <ItemCell>% plot(Y(:,1),Y(:,2),'o')</ItemCell>
            <ItemCell>% Scatter plot matrix with univariate boxplot on the main diagonal</ItemCell>
            <ItemCell>spmplot(Y(:,1:2),Y(:,3),[],'box')</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0,1000,'nsamp',100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0,10,'nsamp',100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.1,1,'nsamp',1000,'plots',1,'equalweights',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.1,1000,'nsamp',100,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust in presence of structured noise.</Title>
         <Desc>
            <ItemCell>The data have been generated using the following R instructions set.seed (0) v &amp;lt;- runif (100, -2 * pi, 2 * pi) noise &amp;lt;- cbind (100 + 25 * sin (v), 10 + 5 * v) x &amp;lt;- rbind ( rmvnorm (360, c (0.0, 0), matrix (c (1, 0, 0, 1), ncol = 2)), rmvnorm (540, c (5.0, 10), matrix (c (6, -2, -2, 6), ncol = 2)), noise)</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>Y=load('structurednoise.txt');</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),2,0.1,100,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),5,0.15,1,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data.</Title>
         <Desc>
            <ItemCell>The data have been generated using the following R instructions set.seed (100) mixt &amp;lt;- rbind (rmvnorm (360, c ( 0, 0), matrix (c (1, 0, 0, 1), ncol = 2)), rmvnorm (540, c ( 5, 10), matrix (c (6, -2, -2, 6), ncol = 2)), rmvnorm (100, c (2.5, 5), matrix (c (50, 0, 0, 50), ncol = 2)))</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>Y=load('mixture100.txt');</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)</ItemCell>
            <ItemCell>out=tclust(Y(:,1:2),3,0.05,1,'refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data, comparison of different options.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('mixture100.txt');</ItemCell>
            <ItemCell>% Traditional tclust</ItemCell>
            <ItemCell>out1=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)</ItemCell>
            <ItemCell>% tclust with mixture models (selection of untrimmed units according to</ItemCell>
            <ItemCell>% likelihood contributions</ItemCell>
            <ItemCell>out2=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',1)</ItemCell>
            <ItemCell>% Tclust with mixture models (selection of untrimmed units according to</ItemCell>
            <ItemCell>% densities weighted by estimates of the probability of the components)</ItemCell>
            <ItemCell>out3=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',2)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust using simulated data.</Title>
         <Desc>
            <ItemCell>5 groups and 5 variables</ItemCell>
         </Desc>
         <MATLABcode>
            <ItemCell>n1=100;</ItemCell>
            <ItemCell>n2=80;</ItemCell>
            <ItemCell>n3=50;</ItemCell>
            <ItemCell>n4=80;</ItemCell>
            <ItemCell>n5=70;</ItemCell>
            <ItemCell>v=5;</ItemCell>
            <ItemCell>Y1=randn(n1,v)+5;</ItemCell>
            <ItemCell>Y2=randn(n2,v)+3;</ItemCell>
            <ItemCell>Y3=rand(n3,v)-2;</ItemCell>
            <ItemCell>Y4=rand(n4,v)+2;</ItemCell>
            <ItemCell>Y5=rand(n5,v);</ItemCell>
            <ItemCell>group=ones(n1+n2+n3+n4+n5,1);</ItemCell>
            <ItemCell>group(n1+1:n1+n2)=2;</ItemCell>
            <ItemCell>group(n1+n2+1:n1+n2+n3)=3;</ItemCell>
            <ItemCell>group(n1+n2+n3+1:n1+n2+n3+n4)=4;</ItemCell>
            <ItemCell>group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;</ItemCell>
            <ItemCell>Y=[Y1;Y2;Y3;Y4;Y5];</ItemCell>
            <ItemCell>out=tclust(Y,5,0.05,1.3,'refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for geyser data.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>maxk=6;</ItemCell>
            <ItemCell>CLACLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>out=tclust(Y,j,0.1,5,'msg',0);</ItemCell>
            <ItemCell>CLACLA(j,2)=out.CLACLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>MIXCLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>MIXMIX=MIXCLA;</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>out=tclust(Y,j,0.1,5,'mixt',2,'msg',0);</ItemCell>
            <ItemCell>MIXMIX(j,2)=out.MIXMIX;</ItemCell>
            <ItemCell>MIXCLA(j,2)=out.MIXCLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,1)</ItemCell>
            <ItemCell>plot(CLACLA(:,1),CLACLA(:,2))</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('CLACLA')</ItemCell>
            <ItemCell>subplot(1,3,2)</ItemCell>
            <ItemCell>plot(MIXMIX(:,1),MIXMIX(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXMIX')</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,3)</ItemCell>
            <ItemCell>plot(MIXCLA(:,1),MIXCLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXCLA (ICL)')</ItemCell>
            <ItemCell>xlim([1 maxk])</ItemCell>
         </MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for simulated data with k=5 and v=5.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>n1=100;     % Generate 5 groups in 5 dimensions</ItemCell>
            <ItemCell>n2=80;</ItemCell>
            <ItemCell>n3=50;</ItemCell>
            <ItemCell>n4=80;</ItemCell>
            <ItemCell>n5=70;</ItemCell>
            <ItemCell>v=5;</ItemCell>
            <ItemCell>Y1=randn(n1,v)+5;</ItemCell>
            <ItemCell>Y2=randn(n2,v)+3;</ItemCell>
            <ItemCell>Y3=rand(n3,v)-2;</ItemCell>
            <ItemCell>Y4=rand(n4,v)+2;</ItemCell>
            <ItemCell>Y5=rand(n5,v);</ItemCell>
            <ItemCell>group=ones(n1+n2+n3+n4+n5,1);</ItemCell>
            <ItemCell>group(n1+1:n1+n2)=2;</ItemCell>
            <ItemCell>group(n1+n2+1:n1+n2+n3)=3;</ItemCell>
            <ItemCell>group(n1+n2+n3+1:n1+n2+n3+n4)=4;</ItemCell>
            <ItemCell>group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;</ItemCell>
            <ItemCell>Y=[Y1;Y2;Y3;Y4;Y5];</ItemCell>
            <ItemCell>restrfactor=5;</ItemCell>
            <ItemCell>maxk=7;</ItemCell>
            <ItemCell>CLACLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>out=tclust(Y,j,0.1,restrfactor);</ItemCell>
            <ItemCell>CLACLA(j,2)=out.CLACLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>MIXCLA=[(1:maxk)' zeros(maxk,1)];</ItemCell>
            <ItemCell>MIXMIX=MIXCLA;</ItemCell>
            <ItemCell>for j=1:maxk</ItemCell>
            <ItemCell>out=tclust(Y,j,0.1,restrfactor,'mixt',2);</ItemCell>
            <ItemCell>MIXMIX(j,2)=out.MIXMIX;</ItemCell>
            <ItemCell>MIXCLA(j,2)=out.MIXCLA;</ItemCell>
            <ItemCell>end</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,1)</ItemCell>
            <ItemCell>plot(CLACLA(:,1),CLACLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('CLACLA')</ItemCell>
            <ItemCell>subplot(1,3,2)</ItemCell>
            <ItemCell>plot(MIXMIX(:,1),MIXMIX(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXMIX')</ItemCell>
            <ItemCell/>
            <ItemCell>subplot(1,3,3)</ItemCell>
            <ItemCell>plot(MIXCLA(:,1),MIXCLA(:,2))</ItemCell>
            <ItemCell>xlabel('Number of groups')</ItemCell>
            <ItemCell>ylabel('MIXCLA (ICL)')</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to Swiss banknotes imposing determinant restriciton.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>load('swiss_banknotes');</ItemCell>
            <ItemCell>Y=swiss_banknotes.data;</ItemCell>
            <ItemCell>out=tclust(Y,3,0.1,10,'restr','deter','refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the Geyser data imposing determinant restriciton.</Title>
         <Desc> </Desc>
         <MATLABcode>
            <ItemCell>Y=load('geyser2.txt');</ItemCell>
            <ItemCell>out=tclust(Y,4,0.1,10,'restr','deter','refsteps',20,'plots',1)</ItemCell>
         </MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>