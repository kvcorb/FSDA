<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->MMregcore</Title>
   <Purpose><!--This is the second line of the .m file-->MMregcore computes MM regression estimators for a selected fixed scale.</Purpose>
   <Description><!--Description section--></Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>y</Name>
         <ShortDesc>Response variable</ShortDesc>
         <TypeInd>Vector</TypeInd>
         <LongDesc>A vector with n elements that contains&#xD;
       the response variable. y can be either a row or a column vector.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>X</Name>
         <ShortDesc>Data matrix of explanatory variables (also called 'regressors') of&#xD;
       dimension (n x p-1)</ShortDesc>
         <TypeInd>Rows of X represent observations, and columns&#xD;
       represent variables</TypeInd>
         <LongDesc>Missing values (NaN's) and infinite values (Inf's) are allowed,&#xD;
       since observations (rows) with missing or infinite values will&#xD;
       automatically be excluded from the computations.</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>b0</Name>
         <ShortDesc>Initial estimate of beta</ShortDesc>
         <TypeInd>Vector</TypeInd>
         <LongDesc>Vector containing initial&#xD;
               estimate of beta (generally an S estimate with high&#xD;
               breakdown point (e.g. 0.5)</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>auxscale</Name>
         <ShortDesc>scale estimate</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Scalar containing estimate of the scale (generally an S&#xD;
               estimate with high breakdown point (e.g. .5)</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>intercept</Name>
         <ShortDesc>Indicator for constant term</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>If 1, a model with&#xD;
               constant term will be fitted (default), if 0, no constant&#xD;
               term will be included.&#xD;
               </LongDesc>
         <Example> 'intercept',1 &#xD;
               </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>eff</Name>
         <ShortDesc>nominal efficiency</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Scalar defining nominal efficiency (i.e. a number between&#xD;
                 0.5 and 0.99). The default value is 0.95&#xD;
                 Asymptotic nominal efficiency is:&#xD;
                 $(\int \psi' d\Phi)^2 / (\psi^2 d\Phi)$&#xD;
                 </LongDesc>
         <Example> 'eff',0.99&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>effshape</Name>
         <ShortDesc>locacation or scale effiicency</ShortDesc>
         <TypeInd>dummy scalar</TypeInd>
         <LongDesc>If effshape=1 efficiency refers to shape &#xD;
                efficiency else (default) efficiency refers to location&#xD;
                 </LongDesc>
         <Example> 'effshape',1&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refsteps</Name>
         <ShortDesc>Maximum iterations</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Scalar defining maximum number of iterations in the MM&#xD;
                 loop. Default value is 100.&#xD;
                 </LongDesc>
         <Example> 'refsteps',10&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftol</Name>
         <ShortDesc>Tolerance</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Scalar controlling tolerance in the MM loop.&#xD;
                 Default value is 1e-7&#xD;
                 </LongDesc>
         <Example> 'tol',1e-10&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>conflev</Name>
         <ShortDesc>Confidence level which is&#xD;
               used to declare units as outliers</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Usually conflev=0.95, 0.975 0.99 (individual alpha)&#xD;
               or 1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha).&#xD;
               Default value is 0.975&#xD;
                 </LongDesc>
         <Example> 'conflev',0.99&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>rhofunc</Name>
         <ShortDesc>rho function</ShortDesc>
         <TypeInd>String</TypeInd>
         <LongDesc>String which specifies the rho function which must be used to&#xD;
               weight the residuals. Possible values are&#xD;
               'bisquare'&#xD;
               'optimal'&#xD;
               'hyperbolic'&#xD;
               'hampel'&#xD;
               'bisquare' uses Tukey's $\rho$ and $\psi$ functions.&#xD;
               See TBrho and TBpsi&#xD;
               'optimal' uses optimal $\rho$ and $\psi$ functions.&#xD;
               See OPTrho and OPTpsi&#xD;
               'hyperbolic' uses hyperbolic $\rho$ and $\psi$ functions.&#xD;
               See HYPrho and HYPpsi&#xD;
               'hampel' uses Hampel $\rho$ and $\psi$ functions.&#xD;
               See HArho and HApsi&#xD;
               The default is bisquare&#xD;
                 </LongDesc>
         <Example> 'rhofunc','optimal' &#xD;
                 </Example>
         <DataType>char</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>rhofuncparam</Name>
         <ShortDesc>Additional parameters for the specified rho function</ShortDesc>
         <TypeInd>Scalar or vector</TypeInd>
         <LongDesc>For hyperbolic rho function it is possible to set up the&#xD;
               value of k = sup CVC (the default value of k is 4.5).&#xD;
               For Hampel rho function it is possible to define parameters&#xD;
               a, b and c (the default values are a=2, b=4, c=8)&#xD;
                 </LongDesc>
         <Example> 'rhofuncparam',5 &#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on&#xD;
                 matrix y and matrix X. Notice that y and X are left&#xD;
                 unchanged. In other words the additional column of ones&#xD;
                 for the intercept is not added. As default nocheck=0.&#xD;
               </LongDesc>
         <Example> 'nocheck',1 &#xD;
               </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen</ShortDesc>
         <TypeInd>Scalar or structure</TypeInd>
         <LongDesc>If plots = 1, generates a plot with the robust residuals&#xD;
               against index number. The confidence level used to draw the&#xD;
               confidence bands for the residuals is given by the input&#xD;
               option conflev. If conflev is not specified a nominal 0.975&#xD;
               confidence interval will be used.&#xD;
                 </LongDesc>
         <Example> 'plots',0 &#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>yxsave</Name>
         <ShortDesc>the response vector y and data matrix X are saved into the output&#xD;
                structure out</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Default is 0, i.e. no saving is done.&#xD;
               </LongDesc>
         <Example> 'yxsave',1 &#xD;
               </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Struct>
            <ItemCell>
               <Value>beta</Value>
               <Description>p x 1 vector. Estimate of beta coefficients after &#xD;
                 refsteps refining steps</Description>
            </ItemCell>
            <ItemCell>
               <Value>residuals</Value>
               <Description>n x 1 vector containing the estimates of the robust&#xD;
                 scaled residuals</Description>
            </ItemCell>
            <ItemCell>
               <Value>outliers</Value>
               <Description>A vector containing the list of the units declared as&#xD;
                 outliers using confidence level specified in input&#xD;
                 scalar conflev</Description>
            </ItemCell>
            <ItemCell>
               <Value>conflev</Value>
               <Description>Confidence level that was used to declare outliers</Description>
            </ItemCell>
            <ItemCell>
               <Value>weights</Value>
               <Description>n x 1 vector. Weights assigned to each observation</Description>
            </ItemCell>
            <ItemCell>
               <Value>class</Value>
               <Description>'MM'</Description>
            </ItemCell>
            <ItemCell>
               <Value>y</Value>
               <Description>response vector y. The field is present if option &#xD;
                yxsave is set to 1.</Description>
            </ItemCell>
            <ItemCell>
               <Value>X</Value>
               <Description>data matrix X. The field is present if option &#xD;
                yxsave is set to 1.</Description>
            </ItemCell>
         </Struct>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->
 It does iterative reweighted least squares (IRWLS) steps from "initial&#xD;
 beta" (b0) keeping the estimate of the scale (auxscale) fixed.&#xD;
&#xD;
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION-->&#xD;
&#xD;
 This function follows the lines of MATLAB/R code developed during the&#xD;
 years by many authors.&#xD;
 For more details see http://www.econ.kuleuven.be/public/NDBAE06/programs/&#xD;
 and the R library robustbase http://robustbase.r-forge.r-project.org/.&#xD;
 The core of these routines, e.g. the resampling approach, however, has&#xD;
 been completely redesigned, with considerable increase of the&#xD;
 computational performance.&#xD;
&#xD;
 </Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Maronna, R.A., Martin D. and Yohai V.J. (2006),Robust Statistics, Theory&#xD;
 and Methods, Wiley, New York.</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>Sreg</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>MMregcore with all default options.</Title>
         <Desc/>
         <MATLABcode>
    n=200;&#xD;
    p=3;&#xD;
    state1=123456;&#xD;
    randn('state', state1);&#xD;
    X=randn(n,p);&#xD;
    y=randn(n,1);&#xD;
    kk=10;&#xD;
    ycont = y;&#xD;
    ycont(1:kk)=ycont(1:kk)+7;&#xD;
    [outS]=Sreg(ycont,X);&#xD;
    outMM=MMregcore(ycont,X,outS.beta,outS.scale)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>MMregcore with optional input arguments.</Title>
         <Desc>&#xD;
     Determine, e.g., an S estimate and extract the required arguments for the MM estimate.&#xD;</Desc>
         <MATLABcode>
    n=200;&#xD;
    p=3;&#xD;
    state1=123456;&#xD;
    randn('state', state1);&#xD;
    X=randn(n,p);&#xD;
    y=randn(n,1);&#xD;
    kk=10;&#xD;
    ycont = y;&#xD;
    ycont(1:kk)=ycont(1:kk)+7;&#xD;
    [outS]=Sreg(ycont,X);&#xD;
    outMM=MMregcore(ycont,X,outS.beta,outS.scale,'plots',1)&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>Weighting the residuals with a rho function.</Title>
         <Desc>&#xD;
     Determine, e.g., an S estimate and extract the required arguments for the MM estimate.&#xD;
     This time use a Tukey biweight for S estimation and HA rho function&#xD;
     for MM loop &#xD;</Desc>
         <MATLABcode>
    n=200;&#xD;
    p=3;&#xD;
    state1=123456;&#xD;
    randn('state', state1);&#xD;
    X=randn(n,p);&#xD;
    y=randn(n,1);&#xD;
    kk=10;&#xD;
    ycont = y;&#xD;
    ycont(1:kk)=ycont(1:kk)+7;&#xD;
    [outS]=Sreg(ycont,X);&#xD;
    rhofunc='hampel';&#xD;
    outMM1=MMregcore(ycont,X,outS.beta,outS.scale,'rhofunc',rhofunc,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>