<?xml version="1.0" encoding="utf-8"?>
<HelpXML>
   <Title><!--This is simply the filename-->tclust</Title>
   <Purpose><!--This is the second line of the .m file-->tclust computes trimmed clustering with restricitons on the eigenvalues</Purpose>
   <Description><!--Description section-->tclust partitions the points in the n-by-v data matrix Y&#xD;
   into k clusters.  This partition minimizes the trimmed sum, over all&#xD;
   clusters, of the within-cluster sums of point-to-cluster-centroid&#xD;
   distances.  Rows of Y correspond to points, columns correspond to&#xD;
   variables. tclust returns inside structure out an n-by-1 vector idx&#xD;
   containing the cluster indices of each point.  By default, tclust uses&#xD;
   (squared), possibly constrained, Mahalanobis distances.</Description>
   <InpArgs><!--REQUIRED INPUT ARGUMENT SECTION-->
      <Item>
         <Name>Y</Name>
         <ShortDesc>Data matrix containining n observations on v variables&#xD;
               Rows of Y represent observations, and columns&#xD;
               represent variables</ShortDesc>
         <TypeInd>Missing values (NaN's) and infinite values (Inf's) are allowed,&#xD;
               since observations (rows) with missing or infinite values will&#xD;
               automatically be excluded from the computations</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>k</Name>
         <ShortDesc>Number of groups</ShortDesc>
         <TypeInd>Scalar which specifies the number of groups</TypeInd>
         <LongDesc> </LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>alpha</Name>
         <ShortDesc>global trimming level</ShortDesc>
         <TypeInd>alpha is a scalar between 0 and 0.5&#xD;
               or an integer specifying the number of observations which have to&#xD;
               be trimmed</TypeInd>
         <LongDesc>If alpha=0 tclust reduces to traditional model&#xD;
               based or mixture clustering (mclust): see Matlab function&#xD;
               gmdistribution.&#xD;
               More in detail, if 0&amp;lt; alpha &amp;lt;1 clustering is based on&#xD;
                h=fix(n*(1-alpha)) observations&#xD;
               Else if alpha is an integer greater than 1 clustering is&#xD;
               based on h=n-floor(alpha);</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restrfactor</Name>
         <ShortDesc>positive scalar which constrains the allowed differences&#xD;
               among group scatters</ShortDesc>
         <TypeInd>Larger values imply larger differences of&#xD;
               group scatters</TypeInd>
         <LongDesc>On the other hand a value of 1 specifies the&#xD;
               strongest restriction forcing all eigenvalues/determinants&#xD;
               to be equal and so the method looks for similarly scattered&#xD;
               (respectively spherical) clusters</LongDesc>
         <Example> </Example>
         <DataType>single| double</DataType>
         <ReqArg>1</ReqArg>
         <Struct> </Struct>
      </Item>
   </InpArgs>
   <OptArgs><!--OPTIONAL (NAME/PAIRS) INPUT ARGUMENT SECTION-->
      <Item>
         <Name>nsamp</Name>
         <ShortDesc>number of subsamples to extract</ShortDesc>
         <TypeInd>Scalar or matrix</TypeInd>
         <LongDesc>If nsamp is a scalar it contains the number of subsamples&#xD;
               which will be extracted. If nsamp=0&#xD;
               all subsets will be extracted.&#xD;
               Remark - if the number of all possible subset is &amp;lt;300 the&#xD;
               default is to extract all subsets, otherwise just 300&#xD;
               If nsamp is a matrix it contains in the rows the indexes of&#xD;
               the subsets which have to be extracted. nsamp in this case&#xD;
               can be conveniently generated  by function subsets. nsamp can&#xD;
               have k columns or k*(v+1) columns. If nsamp has k columns&#xD;
               the k initial centroids each iteration i are given by&#xD;
               X(nsamp(i,:),:) and the covariance matrices are equal to the&#xD;
               identity.&#xD;
               If nsamp has k*(v+1) columns the initial centroids and covariance&#xD;
               matrices in iteration i are computed as follows&#xD;
               X1=X(nsamp(i,:),:)&#xD;
               mean(X1(1:v+1,:)) contains the initial centroid for group 1&#xD;
               cov(X1(1:v+1,:)) contains the initial cov matrix for group 1               1&#xD;
               mean(X1(v+2:2*v+2,:)) contains the initial centroid for group 2&#xD;
               cov((v+2:2*v+2,:)) contains the initial cov matrix for group 2               1&#xD;
               ...&#xD;
               mean(X1((k-1)*v+1:k*(v+1))) contains the initial centroids for group k&#xD;
               cov(X1((k-1)*v+1:k*(v+1))) contains the initial cov matrix for group k&#xD;
               REMARK - if nsamp is not a scalar option option below&#xD;
               startv1 is ignored. More precisely if nsamp has k columns&#xD;
               startv1=0 elseif nsamp has k*(v+1) columns option startv1&#xD;
               =1.&#xD;
                 </LongDesc>
         <Example> 'nsamp',1000&#xD;
                 </Example>
         <DataType>double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>refsteps</Name>
         <ShortDesc>Number of refining iterations</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Number of refining&#xD;
               iterations in each subsample  Default is 15.&#xD;
               refsteps = 0 means "raw-subsampling" without iterations.&#xD;
                 </LongDesc>
         <Example> 'refsteps',10&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>reftol</Name>
         <ShortDesc>tolerance for the refining steps</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>The default value is 1e-14;&#xD;
                 </LongDesc>
         <Example> 'reftol',1e-05&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>equalweights</Name>
         <ShortDesc>cluster weights in the concentration and assignment steps</ShortDesc>
         <TypeInd>Logical</TypeInd>
         <LongDesc>A logical value specifying whether cluster weights&#xD;
               shall be considered in the concentration, assignment steps&#xD;
               and computation of the likelihood.&#xD;
               if equalweights = true we are (ideally) assuming equally&#xD;
               sized groups by maximizing&#xD;
&#xD;
&#xD;
                 \[&#xD;
                 \sum_{j=1}^k \sum_{ x_i \in group_j } \log f(x_i; m_j , S_j)&#xD;
                 \]&#xD;
&#xD;
               else if equalweights = false (default) we allow for different group weights by maximizing&#xD;
&#xD;
                 \[&#xD;
                     \sum_{j=1}^k  \sum_{ x_i \in group_j }  \log \left[ \frac{n_j}{n}  f(x_i; m_j , S_j) \right]=&#xD;
                 \]&#xD;
                 \[&#xD;
                   = \sum_{j=1}^k n_j \log n_j/n + \sum_{j=1}^k \sum_{ x_i \in group_j} \log f(x_i; m_j , S_j)&#xD;
                 \]&#xD;
&#xD;
               Remark: $\sum_{j=1}^k n_j \log n_j/n$ is the so called entropy&#xD;
               term&#xD;
                 </LongDesc>
         <Example> 'equalweights',true&#xD;
                 </Example>
         <DataType>Logical</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>mixt</Name>
         <ShortDesc>mixture modelling or crisp assignmen</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Option mixt specifies whether mixture modelling or crisp&#xD;
               assignment approach to model based clustering must be used.&#xD;
               In the case of mixture modelling parameter mixt also&#xD;
               controls which is the criterior to find the untrimmed units&#xD;
               in each step of the maximization&#xD;
               If mixt &amp;gt;=1 mixture modelling is assumed else crisp&#xD;
               assignment.&#xD;
                In mixture modelling the likelihood is given by&#xD;
                \[&#xD;
                \prod_{i=1}^n  \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j).&#xD;
                \]&#xD;
               while in crisp assignment the likelihood is given by&#xD;
               \[&#xD;
               \prod_{j=1}^k   \prod _{i\in R_j} \phi (y_i; \; \theta_j),&#xD;
               \]&#xD;
               where $R_j$ contains the indexes of the observations which&#xD;
               are assigned to group $j$,&#xD;
               Remark - if mixt&amp;gt;=1 previous parameter equalweights is&#xD;
               automatically set to 1.&#xD;
               Parameter mixt also controls the criterion to select the units to trim&#xD;
               if mixt == 2 the h units are those which give the largest&#xD;
               contribution to the likelihood that is the h largest&#xD;
               values of&#xD;
               \[&#xD;
                   \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j)   \qquad&#xD;
                    i=1, 2, ..., n&#xD;
               \]&#xD;
               elseif mixt==1 the criterion to select the h units is&#xD;
               exactly the same as the one which is used in crisp&#xD;
               assignment. That is: the n units are allocated to a&#xD;
               cluster according to criterion&#xD;
               \[&#xD;
                \max_{j=1, \ldots, k} \hat \pi'_j \phi (y_i; \; \hat \theta_j)&#xD;
               \]&#xD;
               and then these n numbers are ordered and the units&#xD;
               associated with the largest h numbers are untrimmed.&#xD;
               </LongDesc>
         <Example> 'mixt',1&#xD;
               </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>plots</Name>
         <ShortDesc>Plot on the screen</ShortDesc>
         <TypeInd>Scalar or matrix or string</TypeInd>
         <LongDesc>- If plots = 0 (default), plots are not generated.&#xD;
               - If plots = 1, a plot with the classification is shown on&#xD;
                 the screen. The plot can be:&#xD;
                   * for v=1, an histogram of the univariate data.&#xD;
                   * for v=2, a bivariate scatterplot.&#xD;
                   * for v&amp;gt;2, a scatterplot matrix generated by spmplot.&#xD;
               When v = 2, plots offers the following additional features&#xD;
               (for v=1 or v&amp;gt;2 the behaviour is forced that of plots=1):&#xD;
               - plots = 2 superimposes confidence ellipses to the&#xD;
                 bivariate scatterplot. The size of the ellipse is&#xD;
                 chi2inv(0.95,2), i.e. the confidence level used by&#xD;
                 default is 95%.&#xD;
               - 0 &amp;lt; plots &amp;lt; 1 superimposes confidence ellipses with size&#xD;
                 given by chi2inv(plots,2), i.e. with the confidence level&#xD;
                 provided by the user in plots.&#xD;
               - plots = 'contour' superimposes to the bivariate&#xD;
                 scatterplot a contour plot.&#xD;
               - plots = 'contourf' superimposes to the bivariate&#xD;
                 scatterplot a filled contour plot. The colormap of the&#xD;
                 filled contour is based on grey levels.&#xD;
               - If plots is three-column matrix of values in the range&#xD;
                 [0,1], the behaviour is like for 'contourf' but with a&#xD;
                 personalized colormap where each row of 'plots' is an RGB&#xD;
                 triplet that defines one color.&#xD;
               </LongDesc>
         <Example> 'plots',1&#xD;
               </Example>
         <DataType>single | double | matrix | string</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>msg</Name>
         <ShortDesc>Level of output to display</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>Scalar which controls whether to display or not messages&#xD;
               on the screen. If msg==1 (default) messages are displayed&#xD;
               on the screen about estimated time to compute the estimator&#xD;
               or the number of subsets in which there was no convergence&#xD;
               else no message is displayed on the screen&#xD;
                 </LongDesc>
         <Example> 'msg',1&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>nocheck</Name>
         <ShortDesc>Check input arguments</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>If nocheck is equal to 1 no check is performed on&#xD;
               matrix Y.&#xD;
               As default nocheck=0.&#xD;
                 </LongDesc>
         <Example> 'nocheck',10&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>startv1</Name>
         <ShortDesc>how to initialize centroids and cov matrices</ShortDesc>
         <TypeInd>Scalar</TypeInd>
         <LongDesc>If startv1 is 1 then initial&#xD;
               centroids and covariance matrices are based on (v+1)&#xD;
               observations randomly chosen, else each centroid is&#xD;
               initialized taking a random row of input data matrix and&#xD;
               covariance matrices are initialized with identity matrices.&#xD;
               Remark 1- in order to start with a routine which is in the&#xD;
               required parameter space, eigenvalue restrictions are&#xD;
               immediately applied. The default value of startv1 is 1.&#xD;
               Remark 2 - option startv1 is used just if nsamp is a scalar&#xD;
               (see for more details the help associated with nsamp)&#xD;
                 </LongDesc>
         <Example> 'startv1',1&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>restr</Name>
         <ShortDesc>The type of restriction to be applied on the cluster&#xD;
               scatter matrices</ShortDesc>
         <TypeInd>Valid values are 'eigen' (default), or&#xD;
               'deter'</TypeInd>
         <LongDesc>eigen implies restriction on the eigenvalues while&#xD;
               deter implies restrictions on the determinant.&#xD;
                 </LongDesc>
         <Example> 'restr','deter'&#xD;
                 </Example>
         <DataType>char</DataType>
         <Struct> </Struct>
      </Item>
      <Item>
         <Name>Ysave</Name>
         <ShortDesc>Scalar that is set to 1 to request that the input matrix Y&#xD;
               is saved into the output structure out</ShortDesc>
         <TypeInd>Default is 0, i</TypeInd>
         <LongDesc>e.&#xD;
               no saving is done.&#xD;
                        </LongDesc>
         <Example> 'Ysave',1&#xD;
                 </Example>
         <DataType>single | double</DataType>
         <Struct> </Struct>
      </Item>
   </OptArgs>
   <OutArgs><!--OUTPUT ARGUMENT SECTION-->
      <Item>
         <Name>out</Name>
         <ShortDesc> </ShortDesc>
         <TypeInd> </TypeInd>
         <LongDesc> </LongDesc>
         <Struct>
            <ItemCell>
               <Value>muopt</Value>
               <Description>k-by-v matrix containing cluster centroid locations.&#xD;
                       Robust estimate of final centroids of the groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>sigmaopt</Value>
               <Description>v-by-v-by-k array containing estimated constrained&#xD;
                       covariance for the k groups.</Description>
            </ItemCell>
            <ItemCell>
               <Value>idx</Value>
               <Description>n-by-1 vector containing assignment of each unit to&#xD;
                       each of the k groups. Cluster names are integer&#xD;
                       numbers from 1 to k. 0 indicates trimmed&#xD;
                       observations.</Description>
            </ItemCell>
            <ItemCell>
               <Value>siz</Value>
               <Description>matrix of size k-by-3&#xD;
                       1st col = sequence from 0 to k&#xD;
                       2nd col = number of observations in each cluster&#xD;
                       3rd col = percentage of observations in each cluster&#xD;
                       Remark: 0 denotes unassigned units</Description>
            </ItemCell>
            <ItemCell>
               <Value>post</Value>
               <Description>n-by-k matrix containing posterior probabilities&#xD;
                       out.post(i,j) contains posterior probabilitiy of unit&#xD;
                       i from component (cluster) j. For the trimmed units&#xD;
                       posterior probabilities are 0</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXMIX</Value>
               <Description>BIC which uses parameters estimated using the&#xD;
                       mixture loglikelihood and the maximized mixture&#xD;
                       likelihood as goodness of fit measure.&#xD;
                       Remark: this output is present just if input option&#xD;
                       mixt is &amp;gt;0</Description>
            </ItemCell>
            <ItemCell>
               <Value>MIXCLA</Value>
               <Description>BIC which uses the classification likelihood based on&#xD;
                       parameters estimated using the mixture likelihood&#xD;
                       (In some books this quantity is called ICL)&#xD;
                       Remark: this output is present just if input option&#xD;
                       mixt is &amp;gt;0</Description>
            </ItemCell>
            <ItemCell>
               <Value>CLACLA</Value>
               <Description>BIC which uses the classification likelihood based on&#xD;
                       parameters estimated using the classification likelihood&#xD;
                       Remark: this output is present just if input option&#xD;
                       mixt is =0</Description>
            </ItemCell>
            <ItemCell>
               <Value>notconver</Value>
               <Description>scalar. Number of subsets without convergence</Description>
            </ItemCell>
            <ItemCell>
               <Value>bs</Value>
               <Description>k-by-1 vector containing the units forming initial&#xD;
                       subset associated with muopt.</Description>
            </ItemCell>
            <ItemCell>
               <Value>obj</Value>
               <Description>scalar. Value of the objective function which is minimized&#xD;
                       (value of the best returned solution).&#xD;
                       If input option mixt &amp;gt;1 the likelihood which is&#xD;
                       maximized is a mixture likelihood as follows&#xD;
                       \[&#xD;
                       \prod_{i=1}^h  \sum_{j=1}^k \pi_j \phi (y_i; \; \theta_j).&#xD;
                       \]&#xD;
                       else the likelihood which is maximized is a classification likelihood of the the form&#xD;
                       \[&#xD;
                       \prod_{j=1}^k   \prod _{i\in R_j} \pi_j' \phi (y_i; \; \theta_j),&#xD;
                       \]&#xD;
                       where $R_j$ contains the indexes of the observations which are assigned to group $j$&#xD;
                       with the constraint that $\# \bigcup_{j=1}^k&#xD;
                       R_j=h$. In the classification likelihood is input&#xD;
                       option equalweights=0 then $\pi_j'=1$, $j=1, ...,&#xD;
                       k$</Description>
            </ItemCell>
            <ItemCell>
               <Value>equalweights</Value>
               <Description>logical. It is true if in the clustering procedure&#xD;
                       we (ideally) assumed equal cluster weights&#xD;
                       else it is false if we allowed for different&#xD;
                       cluster sizes</Description>
            </ItemCell>
            <ItemCell>
               <Value>h</Value>
               <Description>scalar. Number of observations that have determined the&#xD;
                       centroids (number of untrimmed units).</Description>
            </ItemCell>
            <ItemCell>
               <Value>fullsol</Value>
               <Description>column vector of size nsamp which contains the&#xD;
                       value of the objective function at the end of the&#xD;
                       iterative process for each extracted subsample.</Description>
            </ItemCell>
            <ItemCell>
               <Value>Y</Value>
               <Description>original data matrix Y. The field is present if option&#xD;
                       Ysave is set to 1.</Description>
            </ItemCell>
         </Struct>
      </Item>
      <Item>
         <Name>varargout</Name>
         <ShortDesc> Matrix</ShortDesc>
         <TypeInd>C     : Indexes of extracted subsamples.</TypeInd>
         <LongDesc>&#xD;
                    Matrix of size nsamp-by-(v+1)*k containing (in the&#xD;
                    rows) the indices of the subsamples extracted for&#xD;
                    computing the estimate.</LongDesc>
         <Struct> </Struct>
      </Item>
   </OutArgs>
   <MoreAbout><!--MORE ABOUT SECTION-->
&#xD;
 This iterative algorithm initializes k clusters randomly and&#xD;
 performs "concentration steps" in order to improve the current cluster&#xD;
 assignment. The number of maximum concentration steps to be performed is&#xD;
 given by input parameter refsteps. For approximately obtaining the global&#xD;
 optimum, the system is initialized nsamp times and concentration steps&#xD;
 are performed until convergence or refsteps is reached. When processing&#xD;
 more complex data sets higher values of nsamp and refsteps have to be&#xD;
 specified (obviously implying extra computation time). However, if more&#xD;
 then 10 per cent of the iterations do not converge, a warning message is&#xD;
 issued, indicating that nsamp has to be increased.&#xD;
&#xD;
</MoreAbout>
   <Acknowledgements><!--ACKNOWLEDGEMENTS SECTION--></Acknowledgements>
   <References><!--REFERENCES SECTION-->
      <Item>Garcia-Escudero, L.A.; Gordaliza, A.; Matran, C. and Mayo-Iscar, A. (2008),&#xD;
 "A General Trimming Approach to Robust Cluster Analysis". Annals&#xD;
 of Statistics, Vol.36, 1324-1345. Technical Report available at&#xD;
 http://www.eio.uva.es/inves/grupos/representaciones/trTCLUST.pdf</Item>
   </References>
   <SeeAlso><!--SEE ALSO SECTION-->
      <Item>tkmeans</Item>
      <Item>estepFS</Item>
   </SeeAlso>
   <Ex><!--EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data using k=3, alpha=0.1 and  restrfactor=10000.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('geyser2.txt');&#xD;
    out=tclust(Y,3,0.1,10000);&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust of geyser with classification plot.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('geyser2.txt');&#xD;
    out=tclust(Y,3,0.1,10000,'plots',1);&#xD;
&#xD;
    % tclust of geyser with classification plot and confidence ellipses.&#xD;
    out=tclust(Y,3,0.1,10000,'plots',2);&#xD;
&#xD;
    % tclust of geyser with classification plot and contour plots.&#xD;
    out=tclust(Y,3,0.1,10000,'plots','contour');&#xD;
&#xD;
    % tclust of geyser with classification plot and filled contour plots.&#xD;
    out=tclust(Y,3,0.1,10000,'plots','contourf');&#xD;
&#xD;
    cascade&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust of geyser with varargout.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('geyser2.txt');&#xD;
    nsamp=20;&#xD;
    [out,MatrixContSubsets]=tclust(Y,3,0.1,10000,'nsamp',nsamp);&#xD;
    % MatrixContSubsets is a matrix containing in the rows the indexes of&#xD;
    % the nsamp subsets which have been extracted&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
   </Ex>
   <ExtraEx><!--EXTRA EXAMPLES SECTION-->
      <Item>
         <Title>tclust of geyser data (output comparison).</Title>
         <Desc>&#xD;
     We compare the output using three different values of&#xD;
     restriction factor.&#xD;</Desc>
         <MATLABcode>
    close all&#xD;
    Y=load('geyser2.txt');&#xD;
    restrfactor=10000;&#xD;
    % nsamp = number of subsamples which will be extracted&#xD;
    nsamp=500;&#xD;
    out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'plots',1);&#xD;
    title(['Restriction factor =' num2str(restrfactor)])&#xD;
    restrfactor=10;&#xD;
    out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots',1);&#xD;
    title(['Restriction factor =' num2str(restrfactor)])&#xD;
    % trimmed k-means solution restrfactor=1&#xD;
    restrfactor=1;&#xD;
    out=tclust(Y,3,0.1,restrfactor,'nsamp',nsamp,'refsteps',10,'plots',1);&#xD;
    title(['Restriction factor =' num2str(restrfactor) '. Trimmed k-means solution'])&#xD;
    cascade&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the M5data.</Title>
         <Desc>&#xD;
      A bivariate data set obtained from three normal bivariate distributions&#xD;
      with different scales and proportions 1:2:2. One of the components is very&#xD;
      overlapped with another one. A 10 per cent background noise is added uniformly&#xD;
      distributed in a rectangle containing the three normal components and not&#xD;
      very overlapped with the three mixture components. A precise description&#xD;
      of the M5 data set can be found in Garcia-Escudero et al. (2008).&#xD;</Desc>
         <MATLABcode>
    Y=load('M5data.txt');&#xD;
    % plot(Y(:,1),Y(:,2),'o')&#xD;
    % Scatter plot matrix with univariate boxplot on the main diagonal&#xD;
    spmplot(Y(:,1:2),Y(:,3),[],'box')&#xD;
&#xD;
    out=tclust(Y(:,1:2),3,0,1000,'nsamp',100,'plots',1)&#xD;
    out=tclust(Y(:,1:2),3,0,10,'nsamp',100,'plots',1)&#xD;
    out=tclust(Y(:,1:2),3,0.1,1,'nsamp',1000,'plots',1,'equalweights',1)&#xD;
    out=tclust(Y(:,1:2),3,0.1,1000,'nsamp',100,'plots',1)&#xD;
&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust in presence of structured noise.</Title>
         <Desc>&#xD;
     The data have been generated using the following R instructions&#xD;
        set.seed (0)&#xD;
        v &amp;lt;- runif (100, -2 * pi, 2 * pi)&#xD;
        noise &amp;lt;- cbind (100 + 25 * sin (v), 10 + 5 * v)&#xD;
    &#xD;
        x &amp;lt;- rbind (&#xD;
            rmvnorm (360, c (0.0,  0), matrix (c (1,  0,  0, 1), ncol = 2)),&#xD;
            rmvnorm (540, c (5.0, 10), matrix (c (6, -2, -2, 6), ncol = 2)),&#xD;
            noise)&#xD;
&#xD;</Desc>
         <MATLABcode>
    Y=load('structurednoise.txt');&#xD;
    out=tclust(Y(:,1:2),2,0.1,100,'plots',1)&#xD;
    out=tclust(Y(:,1:2),5,0.15,1,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data.</Title>
         <Desc>&#xD;
     The data have been generated using the following R instructions&#xD;
         set.seed (100)&#xD;
         mixt &amp;lt;- rbind (rmvnorm (360, c (  0,  0), matrix (c (1,  0,  0,  1), ncol = 2)),&#xD;
                    rmvnorm (540, c (  5, 10), matrix (c (6, -2, -2,  6), ncol = 2)),&#xD;
                    rmvnorm (100, c (2.5,  5), matrix (c (50, 0,  0, 50), ncol = 2)))&#xD;
&#xD;</Desc>
         <MATLABcode>
    Y=load('mixture100.txt');&#xD;
    out=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)&#xD;
    out=tclust(Y(:,1:2),3,0.05,1,'refsteps',20,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to mixture100 data, comparison of different options.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('mixture100.txt');&#xD;
    % Traditional tclust&#xD;
    out1=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1)&#xD;
    % tclust with mixture models (selection of untrimmed units according to&#xD;
    % likelihood contributions&#xD;
    out2=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',1)&#xD;
    % Tclust with mixture models (selection of untrimmed units according to&#xD;
    % densities weighted by estimates of the probability of the components)&#xD;
    out3=tclust(Y(:,1:2),3,0.05,1000,'refsteps',20,'plots',1,'mixt',2)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust using simulated data.</Title>
         <Desc>&#xD;
     5 groups and 5 variables&#xD;</Desc>
         <MATLABcode>
    n1=100;&#xD;
    n2=80;&#xD;
    n3=50;&#xD;
    n4=80;&#xD;
    n5=70;&#xD;
    v=5;&#xD;
    Y1=randn(n1,v)+5;&#xD;
    Y2=randn(n2,v)+3;&#xD;
    Y3=rand(n3,v)-2;&#xD;
    Y4=rand(n4,v)+2;&#xD;
    Y5=rand(n5,v);&#xD;
&#xD;
    group=ones(n1+n2+n3+n4+n5,1);&#xD;
    group(n1+1:n1+n2)=2;&#xD;
    group(n1+n2+1:n1+n2+n3)=3;&#xD;
    group(n1+n2+n3+1:n1+n2+n3+n4)=4;&#xD;
    group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;&#xD;
&#xD;
&#xD;
    Y=[Y1;Y2;Y3;Y4;Y5];&#xD;
    out=tclust(Y,5,0.05,1.3,'refsteps',20,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for geyser data.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('geyser2.txt');&#xD;
    maxk=6;&#xD;
    CLACLA=[(1:maxk)' zeros(maxk,1)];&#xD;
    for j=1:maxk&#xD;
        out=tclust(Y,j,0.1,5,'msg',0);&#xD;
        CLACLA(j,2)=out.CLACLA;&#xD;
    end&#xD;
 &#xD;
    MIXCLA=[(1:maxk)' zeros(maxk,1)];&#xD;
    MIXMIX=MIXCLA;&#xD;
    for j=1:maxk&#xD;
        out=tclust(Y,j,0.1,5,'mixt',2,'msg',0);&#xD;
        MIXMIX(j,2)=out.MIXMIX;&#xD;
        MIXCLA(j,2)=out.MIXCLA;&#xD;
    end&#xD;
    &#xD;
    subplot(1,3,1)&#xD;
    plot(CLACLA(:,1),CLACLA(:,2))&#xD;
    xlim([1 maxk])&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('CLACLA')&#xD;
&#xD;
    subplot(1,3,2)&#xD;
    plot(MIXMIX(:,1),MIXMIX(:,2))&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('MIXMIX')&#xD;
    xlim([1 maxk])&#xD;
&#xD;
    &#xD;
    subplot(1,3,3)&#xD;
    plot(MIXCLA(:,1),MIXCLA(:,2))&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('MIXCLA (ICL)')&#xD;
    xlim([1 maxk])&#xD;</MATLABcode>
         <Exec>1</Exec>
      </Item>
      <Item>
         <Title>Automatic choice of the best number of groups for simulated data with&#xD;
     k=5 and v=5.</Title>
         <Desc/>
         <MATLABcode>
    n1=100;     % Generate 5 groups in 5 dimensions&#xD;
    n2=80;&#xD;
    n3=50;&#xD;
    n4=80;&#xD;
    n5=70;&#xD;
    v=5;&#xD;
    Y1=randn(n1,v)+5;&#xD;
    Y2=randn(n2,v)+3;&#xD;
    Y3=rand(n3,v)-2;&#xD;
    Y4=rand(n4,v)+2;&#xD;
    Y5=rand(n5,v);&#xD;
&#xD;
    group=ones(n1+n2+n3+n4+n5,1);&#xD;
    group(n1+1:n1+n2)=2;&#xD;
    group(n1+n2+1:n1+n2+n3)=3;&#xD;
    group(n1+n2+n3+1:n1+n2+n3+n4)=4;&#xD;
    group(n1+n2+n3+n4+1:n1+n2+n3+n4+n5)=5;&#xD;
&#xD;
&#xD;
    Y=[Y1;Y2;Y3;Y4;Y5];&#xD;
    restrfactor=5;&#xD;
    maxk=7;&#xD;
    CLACLA=[(1:maxk)' zeros(maxk,1)];&#xD;
    for j=1:maxk&#xD;
        out=tclust(Y,j,0.1,restrfactor);&#xD;
        CLACLA(j,2)=out.CLACLA;&#xD;
    end&#xD;
 &#xD;
    MIXCLA=[(1:maxk)' zeros(maxk,1)];&#xD;
    MIXMIX=MIXCLA;&#xD;
    for j=1:maxk&#xD;
        out=tclust(Y,j,0.1,restrfactor,'mixt',2);&#xD;
        MIXMIX(j,2)=out.MIXMIX;&#xD;
        MIXCLA(j,2)=out.MIXCLA;&#xD;
    end&#xD;
    &#xD;
    subplot(1,3,1)&#xD;
    plot(CLACLA(:,1),CLACLA(:,2))&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('CLACLA')&#xD;
&#xD;
    subplot(1,3,2)&#xD;
    plot(MIXMIX(:,1),MIXMIX(:,2))&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('MIXMIX')&#xD;
&#xD;
    &#xD;
    subplot(1,3,3)&#xD;
    plot(MIXCLA(:,1),MIXCLA(:,2))&#xD;
    xlabel('Number of groups')&#xD;
    ylabel('MIXCLA (ICL)')&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to Swiss banknotes imposing determinant restriciton.</Title>
         <Desc/>
         <MATLABcode>
    load('swiss_banknotes');&#xD;
    Y=swiss_banknotes.data;&#xD;
    out=tclust(Y,3,0.1,10,'restr','deter','refsteps',20,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
      <Item>
         <Title>tclust applied to the Geyser data imposing determinant restriciton.</Title>
         <Desc/>
         <MATLABcode>
    Y=load('geyser2.txt');&#xD;
    out=tclust(Y,4,0.1,10,'restr','deter','refsteps',20,'plots',1)&#xD;</MATLABcode>
         <Exec>0</Exec>
      </Item>
   </ExtraEx>
</HelpXML>